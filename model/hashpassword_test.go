// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=HashPassword_ea0347143c
ROOST_METHOD_SIG_HASH=HashPassword_fc69fabec5

Scenario 1: Verify Hashing a Valid Password

Details:
    Description: This scenario tests the primary functionality of the HashPassword function, verifying that a valid (non-empty) password can be correctly hashed. 

Execution:
    Arrange: Create a User instance with the 'Password' field filled with a valid string.
    Act: Invoke the HashPassword function with the user instance.
    Assert: Use the bcrypt.CompareHashAndPassword function to verify that the returned hashed password (now in u.Password) matches the original, and that no error was returned from the HashPassword function.

Validation:
    The CompareHashAndPassword function from the bcrypt package provides a reliable way to check that the hashing was successful. The transformation should be correct for the application to function as required.
    
Scenario 2: Attempting to Hash an Empty Password

Details:
    Description: This test scenario validates the functionality of HashPassword when passed an empty password to ensure it returns an appropriate error.

Execution:
    Arrange: Create a User instance with the 'Password' field left empty.
    Act: Invoke HashPassword function on the User instance.
    Assert: Confirm that an error was returned, and that it matches the expected error for an empty password.

Validation:
    The function is explicitly designed to reject empty passwords, so the test needs to confirm this. Ensuring the function can handle and report errors correctly is important for robust code.

Scenario 3: Validating the Change to the User's Password After Hashing

Details:
    Description: This test scenario checks that the HashPassword function correctly updates the 'Password' field of the User instance.

Execution:
    Arrange: Create a User instance with 'Password' filled with a known string. Store a copy of the original Password value.
    Act: Invoke the HashPassword function on the User instance.
    Assert: Confirm that the User's 'Password' field no longer matches the stored original, indicating it was altered by the function.

Validation:
    For the User's password to be securely stored, it must be replaced in the User struct by its hashed version. This test confirms that that is happening as it should be.
    
Scenario 4: Verifying that HashPassword Does Not Alter Other User Fields

Details:
    Description: The test assures that HashPassword should only modify the 'Password' field and that other fields remain unaffected.

Execution:
    Arrange: Create a User instance with all fields filled out. Keep a copy of the User instance.
    Act: Invoke the HashPassword function on the User instance.
    Assert: Confirm that all other fields (except the 'Password' field) on the User instance still match their original values.

Validation:
    Ensuring that a function only modifies the data it's supposed to is basic to good code function and reliability. This test verifies that extraneous alterations do not occur.

*/

// ********RoostGPT********
package model

import (
	"errors"
	"testing"

	"github.com/jinzhu/gorm"
	"golang.org/x/crypto/bcrypt"
)

type User struct {
	gorm.Model
	Username		string
	Password		string
}

// HashPassword hashes password
func (u *User) HashPassword() error {
	if u.Password == "" {
		return errors.New("password should not be empty")
	}
	h, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	u.Password = string(h)
	return nil
}

func TestHashPassword(t *testing.T) {
	bcryptDefaultCost := 10
    
    // Table of test cases
	testCases := []struct {
		name     string // name of the test
		password string // input password for testing
		isErr    bool   // expected error
	}{
		{
			"Testing Valid Password",
			"validPassword",
			false,
		},
		{
			"Testing Empty Password",
			"",
			true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			u := &User{
				Password: tc.password,
			}
			
			// store original password
			oriPassword := u.Password

			err := u.HashPassword()

			if tc.isErr {
				// expecting error
				if err == nil {
					t.Errorf("Expecting error but didn't get any")
					return
				}
				// If error exists, it should be due to an empty password
				if !errors.Is(err, errors.New("password should not be empty")) {
					t.Errorf("Expecting empty password error, instead got: %s", err)
					return
				}
			} else {
				// not expecting any error
				if err != nil {
					t.Errorf("Didn't expect any error, but got: %s", err)
					return
				}

				// Original password should not match the hashed password
				if oriPassword == u.Password {
					t.Errorf("Original password matches the hashed password")
					return
				}

				// Hashed password should match bcrypt's output
				if bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(tc.password)) != nil {
					t.Errorf("Hashed password doesn't match bcrypt's output")
				}
			}
		})
	}
}
