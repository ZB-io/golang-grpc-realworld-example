// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Vertex AI and AI Model claude-3-5-sonnet-v2

ROOST_METHOD_HASH=GetFollowingUserIDs_ba3670aa2c
ROOST_METHOD_SIG_HASH=GetFollowingUserIDs_55ccc2afd7

 writing test scenarios for the GetFollowingUserIDs function. Here are comprehensive test scenarios:

Scenario 1: Successfully Retrieve Following User IDs

Details:
  Description: Verify that the function correctly retrieves a list of user IDs that the given user follows when there are multiple following relationships.
Execution:
  Arrange:
    - Create a test database connection
    - Set up test user (follower) with ID 1
    - Create multiple users being followed (e.g., IDs 2, 3, 4)
    - Establish following relationships in the follows table
  Act:
    - Call GetFollowingUserIDs with the test user
  Assert:
    - Verify returned slice contains expected user IDs [2, 3, 4]
    - Confirm no error is returned
Validation:
    This test ensures the basic functionality of retrieving following relationships works correctly, which is crucial for implementing social features in the application.

Scenario 2: User with No Followings

Details:
  Description: Verify that the function returns an empty slice when the user doesn't follow anyone.
Execution:
  Arrange:
    - Create a test database connection
    - Set up a test user with no following relationships
  Act:
    - Call GetFollowingUserIDs with the test user
  Assert:
    - Verify returned slice is empty
    - Confirm no error is returned
Validation:
    Important to verify correct behavior for users who haven't established any following relationships yet.

Scenario 3: Database Connection Error

Details:
  Description: Verify that the function handles database connection errors appropriately.
Execution:
  Arrange:
    - Set up a mock database that returns an error
    - Create a test user
  Act:
    - Call GetFollowingUserIDs with the test user
  Assert:
    - Verify an empty slice is returned
    - Confirm appropriate error is returned
Validation:
    Essential to ensure proper error handling when database operations fail.

Scenario 4: Invalid User ID

Details:
  Description: Test behavior when called with a user ID that doesn't exist in the database.
Execution:
  Arrange:
    - Set up database connection
    - Create a user with a non-existent ID
  Act:
    - Call GetFollowingUserIDs with the non-existent user
  Assert:
    - Verify empty slice is returned
    - Confirm no error is returned
Validation:
    Important to handle cases where invalid user IDs are provided without causing system errors.

Scenario 5: Deleted User Relationships

Details:
  Description: Verify behavior when accessing following relationships for soft-deleted users.
Execution:
  Arrange:
    - Create test users and following relationships
    - Soft-delete some of the followed users
  Act:
    - Call GetFollowingUserIDs with the test user
  Assert:
    - Verify only active user IDs are returned
    - Confirm no error is returned
Validation:
    Critical to ensure proper handling of soft-deleted records given GORM's soft delete feature.

Scenario 6: Large Number of Followings

Details:
  Description: Test performance and correctness when user follows many other users.
Execution:
  Arrange:
    - Create test user
    - Create large number of following relationships (e.g., 1000)
  Act:
    - Call GetFollowingUserIDs with the test user
  Assert:
    - Verify all expected IDs are returned
    - Confirm no error is returned
    - Check execution time is within acceptable limits
Validation:
    Important to verify function performs well with large datasets and properly handles memory allocation.

These scenarios cover the main functionality, edge cases, and error conditions for the GetFollowingUserIDs function. Each test focuses on a specific aspect of the function's behavior and ensures proper handling of different situations that might occur in a production environment.
*/

// ********RoostGPT********
package store

import (
	"database/sql"
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
	"github.com/raahii/golang-grpc-realworld-example/model"
	"github.com/stretchr/testify/assert"
)

func TestGetFollowingUserIDs(t *testing.T) {
	tests := []struct {
		name      string
		userID    uint
		mockSetup func(sqlmock.Sqlmock)
		expected  []uint
		wantErr   bool
	}{
		{
			name:   "Successfully retrieve following user IDs",
			userID: 1,
			mockSetup: func(mock sqlmock.Sqlmock) {
				rows := sqlmock.NewRows([]string{"to_user_id"}).
					AddRow(2).
					AddRow(3).
					AddRow(4)
				mock.ExpectQuery("SELECT to_user_id FROM follows WHERE").
					WithArgs(1).
					WillReturnRows(rows)
			},
			expected: []uint{2, 3, 4},
			wantErr:  false,
		},
		{
			name:   "User with no followings",
			userID: 1,
			mockSetup: func(mock sqlmock.Sqlmock) {
				rows := sqlmock.NewRows([]string{"to_user_id"})
				mock.ExpectQuery("SELECT to_user_id FROM follows WHERE").
					WithArgs(1).
					WillReturnRows(rows)
			},
			expected: []uint{},
			wantErr:  false,
		},
		{
			name:   "Database connection error",
			userID: 1,
			mockSetup: func(mock sqlmock.Sqlmock) {
				mock.ExpectQuery("SELECT to_user_id FROM follows WHERE").
					WithArgs(1).
					WillReturnError(errors.New("database error"))
			},
			expected: []uint{},
			wantErr:  true,
		},
		{
			name:   "Invalid user ID",
			userID: 999,
			mockSetup: func(mock sqlmock.Sqlmock) {
				rows := sqlmock.NewRows([]string{"to_user_id"})
				mock.ExpectQuery("SELECT to_user_id FROM follows WHERE").
					WithArgs(999).
					WillReturnRows(rows)
			},
			expected: []uint{},
			wantErr:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db, mock, err := sqlmock.New()
			if err != nil {
				t.Fatalf("Failed to create mock DB: %v", err)
			}
			defer db.Close()

			gormDB, err := gorm.Open("mysql", db)
			if err != nil {
				t.Fatalf("Failed to create GORM DB: %v", err)
			}
			defer gormDB.Close()

			tt.mockSetup(mock)

			store := &UserStore{
				db: gormDB,
			}

			user := &model.User{
				Model: gorm.Model{ID: tt.userID},
			}

			got, err := store.GetFollowingUserIDs(user)

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expected, got)
			}

			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("Unfulfilled expectations: %s", err)
			}
		})
	}
}
