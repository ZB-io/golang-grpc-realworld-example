// ********RoostGPT********
/*
Test generated by RoostGPT for test go-deep using AI Type Open Source AI and AI Model meta-llama/Llama-2-13b-chat

ROOST_METHOD_HASH=CreateComment_58d394e2c6
ROOST_METHOD_SIG_HASH=CreateComment_28b95f60a6

FUNCTION_DEF=func (s *ArticleStore) CreateComment(m *model.Comment) error
```
Scenario 1: Successful Creation of a Comment

Details:
  Description: This test checks if the `CreateComment` function successfully creates a comment in the database without any errors. It verifies that the function can handle a valid `model.Comment` object and that the database operation completes successfully.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a valid `model.Comment` object with all required fields populated.
    - Set up the mock database to return no error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the valid `model.Comment` object.

  Assert:
    - Verify that the returned error is `nil`.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function returns no error, indicating that the comment was successfully created in the database. This is crucial for ensuring that the application can handle the basic functionality of adding comments to articles, which is a core feature of the application.

---

Scenario 2: Creation of a Comment with Missing Required Fields

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object that is missing required fields. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with missing required fields (e.g., `Body`, `UserID`, or `ArticleID`).
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the invalid `model.Comment` object.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates the missing required fields.

Validation:
  The assertion checks that the function returns an error when the input is invalid. This is important for ensuring that the application enforces data integrity and provides meaningful feedback when users attempt to create comments with incomplete or invalid data.

---

Scenario 3: Database Error During Comment Creation

Details:
  Description: This test checks how the `CreateComment` function handles a database error during the creation of a comment. It verifies that the function correctly propagates the database error to the caller.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a valid `model.Comment` object.
    - Set up the mock database to return a specific error (e.g., a connection error or a constraint violation) when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the valid `model.Comment` object.

  Assert:
    - Verify that the returned error matches the expected database error.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function correctly handles and propagates database errors. This is important for ensuring that the application can gracefully handle unexpected issues during database operations, providing a robust user experience.

---

Scenario 4: Creation of a Comment with a Non-Existent User

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object where the `UserID` refers to a non-existent user. It verifies that the function returns an appropriate error when the foreign key constraint is violated.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a `UserID` that does not correspond to any existing user in the database.
    - Set up the mock database to return a foreign key constraint violation error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the invalid `UserID`.

  Assert:
    - Verify that the returned error indicates a foreign key constraint violation.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function enforces foreign key constraints and returns an appropriate error when they are violated. This is important for maintaining data integrity and ensuring that comments are only associated with valid users.

---

Scenario 5: Creation of a Comment with a Non-Existent Article

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object where the `ArticleID` refers to a non-existent article. It verifies that the function returns an appropriate error when the foreign key constraint is violated.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with an `ArticleID` that does not correspond to any existing article in the database.
    - Set up the mock database to return a foreign key constraint violation error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the invalid `ArticleID`.

  Assert:
    - Verify that the returned error indicates a foreign key constraint violation.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function enforces foreign key constraints and returns an appropriate error when they are violated. This is important for maintaining data integrity and ensuring that comments are only associated with valid articles.

---

Scenario 6: Creation of a Comment with a Nil Pointer

Details:
  Description: This test checks how the `CreateComment` function handles a `nil` pointer as input. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Set up the mock database to return an error when the `Create` method is called with a `nil` pointer.

  Act:
    - Call the `CreateComment` function with a `nil` pointer.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the input was invalid.

Validation:
  The assertion checks that the function handles `nil` input gracefully and returns an appropriate error. This is important for ensuring that the application can handle unexpected input without crashing or behaving unpredictably.

---

Scenario 7: Creation of a Comment with a Zero Value for UserID or ArticleID

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object where the `UserID` or `ArticleID` is set to zero. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with `UserID` or `ArticleID` set to zero.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the zero value.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the `UserID` or `ArticleID` is invalid.

Validation:
  The assertion checks that the function enforces non-zero values for `UserID` and `ArticleID`. This is important for ensuring that comments are always associated with valid users and articles, maintaining data integrity.

---

Scenario 8: Creation of a Comment with a Large Body Text

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a very large `Body` field. It verifies that the function can handle large text inputs without errors.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a `Body` field containing a large amount of text (e.g., several thousand characters).
    - Set up the mock database to return no error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the large `Body` text.

  Assert:
    - Verify that the returned error is `nil`.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function can handle large text inputs without errors. This is important for ensuring that the application can accommodate users who may want to write lengthy comments, providing a flexible and user-friendly experience.

---

Scenario 9: Creation of a Comment with Special Characters in the Body

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with special characters in the `Body` field. It verifies that the function can handle special characters without errors.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a `Body` field containing special characters (e.g., emojis, non-ASCII characters).
    - Set up the mock database to return no error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the special characters.

  Assert:
    - Verify that the returned error is `nil`.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function can handle special characters in the `Body` field without errors. This is important for ensuring that the application can accommodate a wide range of user inputs, including those with non-standard or special characters.

---

Scenario 10: Creation of a Comment with a Very Long UserID or ArticleID

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a very large `UserID` or `ArticleID`. It verifies that the function can handle large integer values without errors.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a very large `UserID` or `ArticleID` (e.g., close to the maximum value for a `uint`).
    - Set up the mock database to return no error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the large `UserID` or `ArticleID`.

  Assert:
    - Verify that the returned error is `nil`.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function can handle very large integer values for `UserID` and `ArticleID` without errors. This is important for ensuring that the application can scale and handle a wide range of possible values for these fields.

---

Scenario 11: Creation of a Comment with a Negative UserID or ArticleID

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a negative `UserID` or `ArticleID`. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a negative `UserID` or `ArticleID`.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the negative `UserID` or `ArticleID`.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the `UserID` or `ArticleID` is invalid.

Validation:
  The assertion checks that the function enforces non-negative values for `UserID` and `ArticleID`. This is important for ensuring that comments are always associated with valid users and articles, maintaining data integrity.

---

Scenario 12: Creation of a Comment with a Non-Integer UserID or ArticleID

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a non-integer `UserID` or `ArticleID`. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a non-integer `UserID` or `ArticleID` (e.g., a string or floating-point number).
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the non-integer `UserID` or `ArticleID`.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the `UserID` or `ArticleID` is invalid.

Validation:
  The assertion checks that the function enforces integer values for `UserID` and `ArticleID`. This is important for ensuring that comments are always associated with valid users and articles, maintaining data integrity.

---

Scenario 13: Creation of a Comment with a Duplicate Comment ID

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a duplicate `ID`. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with an `ID` that already exists in the database.
    - Set up the mock database to return a duplicate key error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the duplicate `ID`.

  Assert:
    - Verify that the returned error indicates a duplicate key violation.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function enforces unique `ID` values for comments. This is important for ensuring that each comment has a unique identifier, maintaining data integrity and preventing conflicts.

---

Scenario 14: Creation of a Comment with a Future Timestamp

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a future timestamp in the `CreatedAt` or `UpdatedAt` fields. It verifies that the function can handle future timestamps without errors.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a future timestamp in the `CreatedAt` or `UpdatedAt` fields.
    - Set up the mock database to return no error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the future timestamp.

  Assert:
    - Verify that the returned error is `nil`.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function can handle future timestamps without errors. This is important for ensuring that the application can accommodate comments with timestamps that may be set in the future, providing flexibility in how comments are managed.

---

Scenario 15: Creation of a Comment with a DeletedAt Timestamp

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a `DeletedAt` timestamp. It verifies that the function can handle soft-deleted comments without errors.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a `DeletedAt` timestamp set.
    - Set up the mock database to return no error when the `Create` method is called.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the `DeletedAt` timestamp.

  Assert:
    - Verify that the returned error is `nil`.
    - Optionally, verify that the `Create` method was called with the correct `model.Comment` object.

Validation:
  The assertion checks that the function can handle soft-deleted comments without errors. This is important for ensuring that the application can manage comments that have been marked as deleted but are still retained in the database for potential recovery or auditing purposes.

---

Scenario 16: Creation of a Comment with a Non-Existent Tag

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a non-existent tag. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a tag that does not exist in the database.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the non-existent tag.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the tag is invalid.

Validation:
  The assertion checks that the function enforces valid tags for comments. This is important for ensuring that comments are only associated with valid tags, maintaining data integrity and providing a consistent user experience.

---

Scenario 17: Creation of a Comment with a Non-Existent Favorite User

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a non-existent favorite user. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a favorite user that does not exist in the database.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the non-existent favorite user.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the favorite user is invalid.

Validation:
  The assertion checks that the function enforces valid favorite users for comments. This is important for ensuring that comments are only associated with valid users, maintaining data integrity and providing a consistent user experience.

---

Scenario 18: Creation of a Comment with a Non-Existent Followed User

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a non-existent followed user. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a followed user that does not exist in the database.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the non-existent followed user.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the followed user is invalid.

Validation:
  The assertion checks that the function enforces valid followed users for comments. This is important for ensuring that comments are only associated with valid users, maintaining data integrity and providing a consistent user experience.

---

Scenario 19: Creation of a Comment with a Non-Existent Favorite Article

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a non-existent favorite article. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a favorite article that does not exist in the database.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the non-existent favorite article.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the favorite article is invalid.

Validation:
  The assertion checks that the function enforces valid favorite articles for comments. This is important for ensuring that comments are only associated with valid articles, maintaining data integrity and providing a consistent user experience.

---

Scenario 20: Creation of a Comment with a Non-Existent Followed Article

Details:
  Description: This test checks how the `CreateComment` function handles a `model.Comment` object with a non-existent followed article. It verifies that the function returns an appropriate error when the input is invalid.

Execution:
  Arrange:
    - Create a mock `gorm.DB` instance.
    - Create a `model.Comment` object with a followed article that does not exist in the database.
    - Set up the mock database to return an error when the `Create` method is called with an invalid object.

  Act:
    - Call the `CreateComment` function with the `model.Comment` object containing the non-existent followed article.

  Assert:
    - Verify that the returned error is not `nil`.
    - Optionally, verify that the error message indicates that the followed article is invalid.

Validation:
  The assertion checks that the function enforces valid followed articles for comments. This is important for ensuring that comments are only associated with valid articles, maintaining data integrity and providing a consistent user experience.
```
*/

// ********RoostGPT********
package store

import (
	"errors"
	"testing"
	"time"

	"github.com/jinzhu/gorm"
	"github.com/raahii/golang-grpc-realworld-example/model"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// MockDB is a mock implementation of gorm.DB for testing purposes.
type MockDB struct {
	mock.Mock
}

func (m *MockDB) Create(value interface{}) *gorm.DB {
	args := m.Called(value)
	return args.Get(0).(*gorm.DB)
}

// TestArticleStoreCreateComment is a table-driven test for the CreateComment function.
func TestArticleStoreCreateComment(t *testing.T) {
	tests := []struct {
		name        string
		comment     *model.Comment
		mockSetup   func(*MockDB)
		expectedErr error
	}{
		{
			name: "Successful Creation of a Comment",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    1,
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: nil})
			},
			expectedErr: nil,
		},
		{
			name: "Creation of a Comment with Missing Required Fields",
			comment: &model.Comment{
				Body: "", // Missing required field
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("missing required fields")})
			},
			expectedErr: errors.New("missing required fields"),
		},
		{
			name: "Database Error During Comment Creation",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    1,
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("database error")})
			},
			expectedErr: errors.New("database error"),
		},
		{
			name: "Creation of a Comment with a Non-Existent User",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    999, // Non-existent user
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("foreign key constraint violation")})
			},
			expectedErr: errors.New("foreign key constraint violation"),
		},
		{
			name: "Creation of a Comment with a Non-Existent Article",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    1,
				ArticleID: 999, // Non-existent article
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("foreign key constraint violation")})
			},
			expectedErr: errors.New("foreign key constraint violation"),
		},
		{
			name:    "Creation of a Comment with a Nil Pointer",
			comment: nil,
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("nil pointer")})
			},
			expectedErr: errors.New("nil pointer"),
		},
		{
			name: "Creation of a Comment with a Zero Value for UserID or ArticleID",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    0, // Zero value
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("invalid UserID or ArticleID")})
			},
			expectedErr: errors.New("invalid UserID or ArticleID"),
		},
		{
			name: "Creation of a Comment with a Large Body Text",
			comment: &model.Comment{
				Body:      "This is a very large comment body with more than 1000 characters...", // Large body text
				UserID:    1,
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: nil})
			},
			expectedErr: nil,
		},
		{
			name: "Creation of a Comment with Special Characters in the Body",
			comment: &model.Comment{
				Body:      "This is a comment with special characters: ðŸ˜€ðŸŽ‰ðŸš€", // Special characters
				UserID:    1,
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: nil})
			},
			expectedErr: nil,
		},
		{
			name: "Creation of a Comment with a Very Long UserID or ArticleID",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    18446744073709551615, // Max uint value
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: nil})
			},
			expectedErr: nil,
		},
		{
			name: "Creation of a Comment with a Negative UserID or ArticleID",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    0, // Invalid negative value (uint cannot be negative)
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("invalid UserID or ArticleID")})
			},
			expectedErr: errors.New("invalid UserID or ArticleID"),
		},
		{
			name: "Creation of a Comment with a Non-Integer UserID or ArticleID",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    1, // Non-integer value (invalid)
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("invalid UserID or ArticleID")})
			},
			expectedErr: errors.New("invalid UserID or ArticleID"),
		},
		{
			name: "Creation of a Comment with a Duplicate Comment ID",
			comment: &model.Comment{
				Model:     gorm.Model{ID: 1}, // Duplicate ID
				Body:      "This is a valid comment.",
				UserID:    1,
				ArticleID: 1,
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: errors.New("duplicate key violation")})
			},
			expectedErr: errors.New("duplicate key violation"),
		},
		{
			name: "Creation of a Comment with a Future Timestamp",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    1,
				ArticleID: 1,
				Model:     gorm.Model{CreatedAt: time.Now().Add(24 * time.Hour)}, // Future timestamp
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: nil})
			},
			expectedErr: nil,
		},
		{
			name: "Creation of a Comment with a DeletedAt Timestamp",
			comment: &model.Comment{
				Body:      "This is a valid comment.",
				UserID:    1,
				ArticleID: 1,
				Model:     gorm.Model{DeletedAt: &time.Time{}}, // Soft-deleted
			},
			mockSetup: func(mockDB *MockDB) {
				mockDB.On("Create", mock.Anything).Return(&gorm.DB{Error: nil})
			},
			expectedErr: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockDB := new(MockDB)
			tt.mockSetup(mockDB)

			store := &ArticleStore{db: mockDB}
			err := store.CreateComment(tt.comment)

			if tt.expectedErr != nil {
				assert.EqualError(t, err, tt.expectedErr.Error())
			} else {
				assert.NoError(t, err)
			}

			mockDB.AssertExpectations(t)
		})
	}
}
