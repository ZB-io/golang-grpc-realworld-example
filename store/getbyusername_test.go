// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=GetByUsername_f11f114df2
ROOST_METHOD_SIG_HASH=GetByUsername_954d096e24

Scenario 1: Successful retrieval of a user by username

Details:
Description: This test is designed to validate the function's ability to successfully retrieve a user by username. It assures the normal functioning of searching a username in the database.

Execution:
  Arrange: A mock with a specific username needs to be set up in the UserStore. 
  Act: Invoke the GetByUsername function with the mock username.
  Assert: Assert that the returned user object is not nil and the error returned is nil, and the username of the returned user object is equal to the mock username.

Validation:
  The assertion choice is logical as we are expecting a valid user from the function when the username exists in the DB. This test is important to see whether the function is able to retrieve existing users by their usernames correctly or not.
  
Scenario 2: User not found by given username

Details:
Description: This test is to check if the function correctly handles the scenario when there is no user with the given username in the DB.

Execution:
  Arrange: The DB should not contain any user with the mock username.
  Act: Invoke the GetByUsername with a mock username that does not exist in the DB.
  Assert: Assert that the returned user object should be nil and the error should not be nil.

Validation:
  The assertion is logical because we are not expecting anyone to be found with that username. Thus, a nil user and a non-nil error are expected. This is an important test to confirm the function's ability to correctly return an error when the user does not exist in the DB.
  
Scenario 3: Database connection error

Details:
Description: This test is to confirm if the function handles a database connection error correctly. 

Execution:
  Arrange: Simulate a database connection error in your mock UserStore. 
  Act: Invoke the GetByUsername function with any username.
  Assert: Assert that the user object returned is nil and the error is not nil.

Validation:
  The assertion choice is logical since we expect a nil User and a non-nil error to be returned due to the database connection error. This test is important because the function should handle database errors correctly and return the error.
  
Scenario 4: Invalid characters in the username

Details:
Description: This test is to check if the function correctly handles usernames containing non-alphanumeric characters, which could potentially create issues for a SQL query.

Execution:
  Arrange: Setup the database with a user with alphanumeric characters in the username.
  Act: Invoke the GetByUsername function with a username containing non-alphanumeric characters.
  Assert: Assert that the user returned is nil and the error is not nil.

Validation:
  The assertion choice is logical considering usernames with special characters are not valid and thus should not return any user object, and instead an error. It is important to validate this behavior in the function as this is a real-world scenario and a possible attack vector for SQL injection.

*/

// ********RoostGPT********
package store_test

import (
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
	"github.com/raahii/golang-grpc-realworld-example/model"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGetByUsername(t *testing.T) {
	tests := []struct {
		name          string
		mockUsername  string
		mockSetupFunc func(mockDB sqlmock.Sqlmock)
		expectedUser  *model.User
		expectedErr   error
	}{
		{
			name:         "Successful retrieval of a user by username",
			mockUsername: "testUser",
			mockSetupFunc: func(mockDB sqlmock.Sqlmock) {
				rows := sqlmock.NewRows([]string{"id", "username", "email", "password", "bio", "image"}).
					AddRow(1, "testUser", "test@test.com", "$2b$10$7d37nO..", "testBio", "testImage")
				mockDB.ExpectQuery(`SELECT \* FROM "users" WHERE (.+) LIMIT 1\z`).
					WithArgs("testUser").
					WillReturnRows(rows)
			},
			expectedUser: &model.User{
				Username: "testUser",
				Email:    "test@test.com",
				Password: "$2b$10$7d37nO..",
				Bio:      "testBio",
				Image:    "testImage",
			},
			expectedErr: nil,
		},

		// Add more test cases here
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db, mock, err := sqlmock.New()
			require.NoError(t, err)
			gdb, err := gorm.Open("sqlite3", db)
			require.NoError(t, err)

			tt.mockSetupFunc(mock)

			s := &store.UserStore{DB: gdb}

			// Act
			user, err := s.GetByUsername(tt.mockUsername)

			// Assert
			assert.Equal(t, tt.expectedErr, err)
			assert.Equal(t, tt.expectedUser, user)
			assert.NoError(t, mock.ExpectationsWereMet())
		})
	}
}
