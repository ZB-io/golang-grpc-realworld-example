// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=DeleteComment_b345e525a7
ROOST_METHOD_SIG_HASH=DeleteComment_732762ff12

Scenario 1: Normal Operation Test

Details:
  Description: The test is meant to check if a comment can be successfully deleted from the ArticleStore.
Execution:
  Arrange: A `Comment` instance `cmt` will be created with a mock `db` in the `ArticleStore` and a valid ID.
  Act: Invoke the `DeleteComment` function on the `ArticleStore` instance with `cmt` as the parameter.
  Assert: Use Go testing facilities to verify that the function returns `nil`.
Validation:
  The assertion affirms that the function successfully deletes the comment from the database as expected. This aligns with normal operation, where the lack of an error code indicates successful completion. It's important to verify regular operation to ensure that business requirements are met and to maintain a clean, operable database.

Scenario 2: Nonexistent Comment Test

Details:
  Description: The test is meant to check how the function behaves when asked to delete a comment that doesn't exist in the store.
Execution:
  Arrange: A `Comment` instance `cmt` will be created with non-existing ID.
  Act: Invoke the `DeleteComment` function on the `ArticleStore` instance with `cmt` as the parameter.
  Assert: Use Go testing facilities to verify that the function returns an `error`.
Validation:
  The assertion checks that an error is returned, indicating failure to delete a nonexistent comment. Business requirements demand that any operation involving non-existent records be flagged, and the failure to do this indicates a problem with the function's logic.

Scenario 3: Exception Handling Test

Details:
  Description: The test is meant to check how the function handles exceptions/errors from the underlying database (For example, if there's an issue with the database connection).
Execution:
  Arrange: A `Comment` instance `cmt` will be created with valid ID, and a mock `db` in the `ArticleStore` set to return some specific `error` on `Delete`.
  Act: Invoke the `DeleteComment` function on the `ArticleStore` instance with `cmt` as the parameter.
  Assert: Use Go testing facilities to verify that the function returns the same `error` as the mock `db`.
Validation:
  The assertion checks that the function is able to handle exceptions and propagate errors from the underlying database. This is important because it ensures that the function operates as expected in the event of database errors, allowing for graceful failure and accurate error reporting.
*/

// ********RoostGPT********
package store

import (
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
	"github.com/raahii/golang-grpc-realworld-example/model"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
)

type DeleteCommentSuite struct {
	suite.Suite
	Store        *ArticleStore
	SQLMock      sqlmock.Sqlmock
	commentToDel *model.Comment
}

func (suite *DeleteCommentSuite) SetupSuite() {
	db, mock, _ := sqlmock.New()
	suite.SQLMock = mock
	gdb, _ := gorm.Open("postgres", db)
	suite.Store = &ArticleStore{
		db: gdb,
	}
	suite.commentToDel = &model.Comment{
		Model: gorm.Model{
			ID: 1,
		},
		Body:      "test comment",
		UserID:    1,
		ArticleID: 1,
	}
}

func (suite *DeleteCommentSuite) TestDeleteComment_Successful() {
	suite.SQLMock.ExpectBegin()
	suite.SQLMock.ExpectExec("[DELETE FROM](.*)").WillReturnResult(sqlmock.NewResult(1, 1))
	suite.SQLMock.ExpectCommit()

	err := suite.Store.DeleteComment(suite.commentToDel)

	assert.NoError(suite.T(), err)
}

func (suite *DeleteCommentSuite) TestDeleteComment_NonExistent() {
	suite.SQLMock.ExpectBegin()
	suite.SQLMock.ExpectExec("[DELETE FROM](.*)").WillReturnResult(sqlmock.NewResult(1, 0))
	suite.SQLMock.ExpectRollback()

	err := suite.Store.DeleteComment(suite.commentToDel)

	assert.Error(suite.T(), err)
}

func (suite *DeleteCommentSuite) TestDeleteComment_Failure() {
	expectedErr := errors.New("database error")
	suite.SQLMock.ExpectBegin()
	suite.SQLMock.ExpectExec("[DELETE FROM](.*)").WillReturnError(expectedErr)
	suite.SQLMock.ExpectRollback()

	err := suite.Store.DeleteComment(suite.commentToDel)

	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), expectedErr, err)
}

func Testdeletecomment(t *testing.T) {
	suite.Run(t, new(DeleteCommentSuite))
}
