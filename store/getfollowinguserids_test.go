// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=GetFollowingUserIDs_ba3670aa2c
ROOST_METHOD_SIG_HASH=GetFollowingUserIDs_55ccc2afd7

Scenario 1: Fetch all following UserID's successfully.
Details:
    Description: This test checks if the function successfully returns the list of all following UserID's for the provided UserID.
Execution:
    Arrange: Mock the database method "Table", "Select", "Where" and "Rows" to return a rows contain list of UserID's.
    Act: Call the GetFollowingUserIDs function with a valid User model as parameter.
    Assert: Assert that the returned error is nil and the list of UserIDs matches the mock data.
Validation:
    The function should return all IDs successfully. As this is the expected common scenario, this test is crucial to ensure that the function works under normal conditions.


Scenario 2: No following UserID's present.
Details:
    Description: This test checks if the function handles the case where the user is not following anybody.
Execution:
    Arrange: Mock the database method "Table", "Select", "Where" and "Rows" to return an empty row. 
    Act: Call the GetFollowingUserIDs function with a valid User model as parameter.
    Assert: Assert that the returned error is nil and the returned list is empty.
Validation:
    The function should handle the scenario where user is not following anyone and return an empty list, hence validating this scenario is of importance especially in cases of new users.


Scenario 3: Database error while fetching following UserIds.
Details:
    Description: This test checks if the function correctly handles a database error when trying to fetch following User IDs.
Execution:
    Arrange: Mock the database method "Table", "Select", "Where" and "Rows" to return an error.
    Act: Call the GetFollowingUserIDs function with a valid User model as parameter.
    Assert: Assert that the error matches the error returned from the Mock.
Validation:
    In case of DB errors, function should handle and return it back. This test validates the function error handling behaviour in cases of failures.


Scenario 4: Error while scanning rows.
Details:
    Description: This test checks if the function correctly handles an error when trying to scan the rows of user Ids.
Execution:
    Arrange: Mock "Rows" method to return a row set that causes scan failure.
    Act: Call the GetFollowingUserIDs function with a valid User model as parameter.
    Assert: Assert that the right error is returned.
Validation:
    In case of error during scan, function should handle and return it back. This test validates the function error handling behaviour during row scan failure. This is crucial as erroneous data can often lead to scan failures.

These scenarios should cover the primary edge cases, error conditions and common functionality for the function.
*/

// ********RoostGPT********
package store

import (
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
	"github.com/yourusername/yourproject/model"
)

func TestGetFollowingUserIDs(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error was not expected when opening a stub database connection: %s", err)
	}
	gormDB, err := gorm.Open("postgres", db)
	if err != nil {
		t.Fatalf("an error was not expected when opening gorm database: %s", err)
	}
	defer db.Close()

	store := &UserStore{db: gormDB}

	user := &model.User{Model: gorm.Model{ID: 1}}

	rows := sqlmock.NewRows([]string{"to_user_id"}).
		AddRow(2).
		AddRow(3)

	mock.ExpectQuery("^SELECT (.+) FROM \"follows\"*").WithArgs(user.ID).WillReturnRows(rows)
	ids, err := store.GetFollowingUserIDs(user)
	if err != nil {
		t.Errorf("error was not expected while fetching ids: %s", err)
	}
	expectedIds := []uint{2, 3}
	for i, id := range ids {
		if id != expectedIds[i] {
			t.Errorf("expected %v, but got %v", expectedIds, ids)
		}
	}

	mock.ExpectQuery("^SELECT (.+) FROM \"follows\"*").WithArgs(user.ID).WillReturnError(errors.New("database error"))
	_, err = store.GetFollowingUserIDs(user)
	if err == nil {
		t.Errorf("was expecting error, but there was none")
	}

	row := sqlmock.NewRows([]string{"to_user_id"})
	mock.ExpectQuery("^SELECT (.+) FROM \"follows\"*").WithArgs(user.ID).WillReturnRows(row)
	ids, err = store.GetFollowingUserIDs(user)
	if err != nil {
		t.Errorf("not expecting error, but got: %s", err)
	}
	if len(ids) != 0 {
		t.Errorf("expected empty slice, but got: %v", ids)
	}

	mock.ExpectQuery("^SELECT (.+) FROM \"follows\"*").WithArgs(user.ID).WillReturnRows(rows)
	_, err = store.GetFollowingUserIDs(user)
	if err == nil {
		t.Errorf("scan error was expected, but there was none")
	}
}
