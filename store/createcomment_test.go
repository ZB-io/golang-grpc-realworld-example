// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=CreateComment_58d394e2c6
ROOST_METHOD_SIG_HASH=CreateComment_28b95f60a6

Scenario 1: Create Comment with Valid Data
Details:
    Description: This test is meant to check the normal operation scenario when the "CreateComment" function is called with valid comment structure. It is meant to ensure, when the valid input is provided, the function inserts the comment into the database without errors.
Execution:
    Arrange: Create a *model.Comment object with a valid Body, UserID, and ArticleID. Set up a mock for the *gorm.DB data type and simulate the create operation.
    Act: Invoke the "CreateComment" function with the valid *model.Comment object.
    Assert: Ensure there's no error returned.
Validation:
    This assertion is chosen to ensure that normal operation scenario is working correctly with valid input. Since the function's task is to store comments, validating this scenario makes sure that the function properly interacts with the database and the comment is created successfully.

Scenario 2: Create comment with Invalid Data
Details:
    Description: This test checks the case when the "CreateComment" function is called with an invalid (*model.Comment object). The test is meant to check the function's behavior when it attempts to work with invalid data that doesn't adhere to the business rules (for instance, missing Body).
Execution:
    Arrange: Create a *model.Comment object with incomplete data (for instance, empty Body field). Setup mock for the *gorm.DB data type to simulate the create operation.
    Act: Try to create comment using "CreateComment" function with the invalid schema.
    Assert: Ensure an error is returned.
Validation:
    This assertion is made as the function should not accept invalid inputs and should return an error when saving to the database. Understanding how a feature handles invalid workflow is important for ensuring the reliability and stability of the application.

Scenario 3: Create comment into Unresponsive Database
Details:
    Description: This test checks the edge case where the "CreateComment" function is called while the database service is unresponsive. This is to see how the function handles exceptional scenarios where it can't access the database.
Execution:
    Arrange: Simulate an unresponsive database by setting up a mock for the *gorm.DB data type to return an error on create operation. Create a *model.Comment object with valid data.
    Act: Invoke the "CreateComment" function.
    Assert: The function should return the error.
Validation:
    This test scenario demonstrates how the function performs under abnormal conditions. It should return an error and not crash or behave unexpectedly when the access to the database is inhibited. The test represents a realistic situation where the database service might be down.
*/

// ********RoostGPT********
package store_test

import (
    "errors"
    "testing"

    "github.com/DATA-DOG/go-sqlmock"
    "github.com/jinzhu/gorm"
    "github.com/raahii/golang-grpc-realworld-example/model"
    "github.com/raahii/golang-grpc-realworld-example/store"
)

func TestCreateComment(t *testing.T) {
    db, mock, err := sqlmock.New()
    if err != nil {
        t.Fatalf("failed to create sqlmock: %s", err)
    }
    defer db.Close()

    gormDB, err := gorm.Open("mysql", db)
    if err != nil {
        t.Fatalf("failed to open gormDB: %s", err)
    }

    tests := []struct {
        name      string
        prepare   func()
        check     func(repository *store.ArticleStore, err error)
        comment   *model.Comment
    }{
        {
            name: "Create Comment with Valid Data",
            prepare: func() {
                mock.ExpectBegin()
                mock.ExpectExec("^INSERT INTO").WillReturnResult(sqlmock.NewResult(1, 1))
                mock.ExpectCommit()
            },
            check: func(repository *store.ArticleStore, err error) {
                if err != nil {
                    t.Errorf("unexpected error: %s", err)
                }
            },
            comment: &model.Comment{Body: "test body", UserID: 1, ArticleID: 1},
        },
        {
            name: "Create comment with Invalid Data",
            prepare: func() {
                mock.ExpectBegin()
                mock.ExpectExec("^INSERT INTO").WillReturnError(errors.New("failed to create comment"))
                mock.ExpectRollback()
            },
            check: func(repository *store.ArticleStore, err error) {
                if err == nil {
                    t.Error("expected error, but got nil")
                }
            },
            comment: &model.Comment{Body: "", UserID: 0, ArticleID: 0},
        },
        {
            name: "Create comment into Unresponsive Database",
            prepare: func() {
                mock.ExpectBegin()
                mock.ExpectExec("^INSERT INTO").WillReturnError(errors.New("database is down"))
                mock.ExpectRollback()
            },
            check: func(repository *store.ArticleStore, err error) {
                if err == nil {
                    t.Error("expected error, but got nil")
                }
            },
            comment: &model.Comment{Body: "test body", UserID: 1, ArticleID: 1},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            repository := store.NewArticleStore(gormDB)
            tt.prepare()
            err := repository.CreateComment(tt.comment)
            tt.check(repository, err)
            if err := mock.ExpectationsWereMet(); err != nil {
                t.Errorf("there were unfulfilled expectations: %s", err)
            }
        })
    }
}
