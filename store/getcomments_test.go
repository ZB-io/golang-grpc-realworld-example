// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=GetComments_e24a0f1b73
ROOST_METHOD_SIG_HASH=GetComments_fa6661983e

```
Scenario 1: Successful retrieval of comments for a given article 

Details:
  Description: This test is meant to check if the function is able to successfully retrieve all comments associated with a given article.
Execution:
  Arrange: Set up a mock DB, a mock article and associated comments.
  Act: Invoke the GetComments function with the mock article.
  Assert: Verify that the correct Comments are returned and no error is returned.
Validation:
  The assertion should compare the returned comments with the expected comments. The importance of this test is to ensure that the GetComments method is successful in retrieving the correct comments for a given article.

Scenario 2: Error when retrieving comments for a given article

Details:
  Description: This test is meant to check how the function handles an error when retrieving comments for a given article from the database.
Execution:
  Arrange: Set up a mock DB that will return an error when queried, and a mock article.
  Act: Invoke the GetComments function with the mock article.
  Assert: Verify that an error is returned.
Validation:
  The assertion should compare the returned error with the expected error. This test is important because it checks the robustness of the GetComments method in the face of errors from the database.

Scenario 3: No comments found for a given article

Details:
  Description: This test is meant to check if the function can effectively handle a scenario where an article has no comments.
Execution:
  Arrange: Set up a mock DB and a mock article with no associated comments.
  Act: Invoke the GetComments function with the mock article.
  Assert: Ensure that no comment is returned and no error is returned.
Validation:
  The returned comments should not contain any elements. This test is important because it verifies the GetComments method's correct behavior when there are no comments for a given article.

Scenario 4: Invalid Article input

Details:
  Description: This test is meant to check how the function handles an invalid/no Article input.
Execution:
  Arrange: Set up a mock DB and no/invalid article.
  Act: Invoke the GetComments function with no/invalid article.
  Assert: Verify that an error is returned.
Validation:
  The assertion should compare the returned error with the expected error. This test is important because it checks whether the GetComments method can handle invalid/no input properly.
```
*/

// ********RoostGPT********
package store

import (
	"testing"
	"errors"
	"github.com/raahii/golang-grpc-realworld-example/model"
	"github.com/jinzhu/gorm"
	sqlmock "github.com/DATA-DOG/go-sqlmock"
	"github.com/google/go-cmp/cmp"
)

func TestGetComments(t *testing.T) {
	testCases := []struct {
		desc       string
		setupMocks func(mock sqlmock.Sqlmock, article *model.Article)
		article    *model.Article
		expect     []model.Comment
		expectErr  bool
	}{
		{
			"Successful retrieval of comments for a given article",
			func(mock sqlmock.Sqlmock, article *model.Article) {
				rows := sqlmock.NewRows([]string{"id", "body", "user_id", "article_id"}).
					AddRow(1, "test_comment_1", 1, article.ID).
					AddRow(2, "test_comment_2", 1, article.ID)
				mock.ExpectQuery("SELECT (.+) FROM (.+) WHERE article_id = ?").WithArgs(article.ID).WillReturnRows(rows)
			},
			&model.Article{Model: gorm.Model{ID: 1}},
			[]model.Comment{{Model: gorm.Model{ID: 1}, Body: "test_comment_1", UserID: 1, ArticleID: 1}, {Model: gorm.Model{ID: 2}, Body: "test_comment_2", UserID: 1, ArticleID: 1}},
			false,
		},
		{
			"Error when retrieving comments for a given article",
			func(mock sqlmock.Sqlmock, article *model.Article) {
				mock.ExpectQuery("SELECT (.+) FROM (.+) WHERE article_id = ?").WithArgs(article.ID).WillReturnError(errors.New("database error"))
			},
			&model.Article{Model: gorm.Model{ID: 1}},
			nil,
			true,
		},
		{
			"No comments found for a given article",
			func(mock sqlmock.Sqlmock, article *model.Article) {
				mock.ExpectQuery("SELECT (.+) FROM (.+) WHERE article_id = ?").WithArgs(article.ID).WillReturnRows(sqlmock.NewRows([]string{"id", "body", "user_id", "article_id"}))
			},
			&model.Article{Model: gorm.Model{ID: 1}},
			[]model.Comment{},
			false,
		},
		{
			"Invalid Article input",
			func(mock sqlmock.Sqlmock, article *model.Article) {
				mock.ExpectQuery("SELECT (.+) FROM (.+) WHERE article_id = ?").WithArgs(article.ID).WillReturnError(errors.New("invalid article"))
			},
			nil,
			nil,
			true,
		},
	}
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to open sqlmock database: %v", err)
	}
	gdb, err := gorm.Open("mysql", db)
	if err != nil {
		t.Fatalf("failed to open gorm database: %v", err)
	}

	store := ArticleStore{db: gdb}

	for _, tC := range testCases {
		t.Run(tC.desc, func(t *testing.T) {
			tC.setupMocks(mock, tC.article)

			comments, err := store.GetComments(tC.article)

			if (err != nil) != tC.expectErr {
				t.Fatalf("GetComments() error = %v, expectErr: %v", err, tC.expectErr)
				return
			}

			if tC.expectErr {
				t.Logf("expected an error and got one")
				return
			}

			if !cmp.Equal(comments, tC.expect, cmp.AllowUnexported(model.Comment{})) {
				t.Errorf("GetComments() = %v, want: %v", comments, tC.expect)
			}
		})
	}
}
