// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

FUNCTION_DEF=func GetUserID(ctx context.Context) (uint, error)
Based on the provided function and context, here are several test scenarios for the `GetUserID` function:

```
Scenario 1: Valid Token with Correct Claims

Details:
  Description: Test the function with a valid JWT token containing correct claims and a non-expired timestamp.
Execution:
  Arrange:
    - Create a valid JWT token with correct claims including a valid UserID and non-expired timestamp.
    - Set up a mock context with the token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return the correct UserID.
    - Expect no error to be returned.
Validation:
  This test ensures that the function correctly extracts and returns the UserID from a valid token. It's crucial for verifying the basic functionality of the authentication system.

Scenario 2: Expired Token

Details:
  Description: Test the function's behavior when provided with an expired JWT token.
Execution:
  Arrange:
    - Create a JWT token with an expiration time in the past.
    - Set up a mock context with the expired token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return 0 as the UserID.
    - Expect an error with the message "token expired".
Validation:
  This test verifies that the function correctly handles expired tokens, which is essential for maintaining security by rejecting outdated credentials.

Scenario 3: Malformed Token

Details:
  Description: Test the function's response to a malformed JWT token.
Execution:
  Arrange:
    - Create an invalid, malformed token string.
    - Set up a mock context with the malformed token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return 0 as the UserID.
    - Expect an error with a message indicating an invalid token.
Validation:
  This test ensures that the function properly handles and rejects malformed tokens, which is crucial for preventing security vulnerabilities.

Scenario 4: Missing Token in Context

Details:
  Description: Test the function's behavior when no token is present in the context metadata.
Execution:
  Arrange: Set up a mock context without any token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return 0 as the UserID.
    - Expect an error indicating that the token is missing or cannot be extracted from the metadata.
Validation:
  This test verifies that the function correctly handles cases where authentication information is missing, which is important for maintaining secure access control.

Scenario 5: Token with Invalid Claims Structure

Details:
  Description: Test the function with a token that has an invalid claims structure.
Execution:
  Arrange:
    - Create a JWT token with claims that do not match the expected structure (e.g., missing UserID).
    - Set up a mock context with this token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return 0 as the UserID.
    - Expect an error indicating that the claims could not be mapped or are invalid.
Validation:
  This test ensures that the function can handle tokens with unexpected or malformed claim structures, which is important for robustness and security.

Scenario 6: Valid Token with Future NotBefore Claim

Details:
  Description: Test the function's behavior with a token that has a future NotBefore (nbf) claim.
Execution:
  Arrange:
    - Create a JWT token with a NotBefore claim set to a future time.
    - Set up a mock context with this token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return 0 as the UserID.
    - Expect an error indicating that the token is not yet valid.
Validation:
  This test verifies that the function respects the NotBefore claim, which is important for implementing time-based access controls.

Scenario 7: Valid Token with Incorrect Signing Method

Details:
  Description: Test the function's response to a token signed with an unexpected algorithm.
Execution:
  Arrange:
    - Create a JWT token signed with a different algorithm than expected (e.g., HS512 instead of HS256).
    - Set up a mock context with this token in the metadata.
  Act: Call GetUserID with the prepared context.
  Assert:
    - Expect the function to return 0 as the UserID.
    - Expect an error indicating an invalid signing method or token.
Validation:
  This test ensures that the function correctly validates the signing method of the token, which is crucial for preventing potential security vulnerabilities related to algorithm substitution attacks.
```

These scenarios cover a range of normal operations, edge cases, and error handling situations for the `GetUserID` function, providing a comprehensive test suite for its functionality.
*/

// ********RoostGPT********
package auth

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/dgrijalva/jwt-go"
	grpc_auth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"google.golang.org/grpc/metadata"
)

// mockAuthFunc is a mock implementation of grpc_auth.AuthFunc
var mockAuthFunc grpc_auth.AuthFunc = func(ctx context.Context) (context.Context, error) {
	token, err := grpc_auth.AuthFromMD(ctx, "Token")
	if err != nil {
		return nil, err
	}
	return context.WithValue(ctx, "token", token), nil
}

func TestGetUserID(t *testing.T) {
	// Override the global jwtSecret for testing
	jwtSecret = []byte("test_secret")

	// Store the original AuthFromMD function
	originalAuthFromMD := grpc_auth.AuthFromMD

	// Override grpc_auth.AuthFromMD with our mock implementation
	grpc_auth.AuthFromMD = func(ctx context.Context, expectedScheme string) (string, error) {
		md, ok := metadata.FromIncomingContext(ctx)
		if !ok {
			return "", errors.New("no metadata in context")
		}
		values := md.Get(expectedScheme)
		if len(values) == 0 {
			return "", errors.New("no auth token in metadata")
		}
		return values[0], nil
	}

	// Restore the original AuthFromMD function after the test
	defer func() {
		grpc_auth.AuthFromMD = originalAuthFromMD
	}()

	tests := []struct {
		name           string
		setupContext   func() context.Context
		expectedUserID uint
		expectedError  string
	}{
		{
			name: "Valid Token with Correct Claims",
			setupContext: func() context.Context {
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				})
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.Pairs("Token", tokenString)
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedUserID: 123,
			expectedError:  "",
		},
		{
			name: "Expired Token",
			setupContext: func() context.Context {
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(-time.Hour).Unix(),
					},
				})
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.Pairs("Token", tokenString)
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedUserID: 0,
			expectedError:  "token expired",
		},
		{
			name: "Malformed Token",
			setupContext: func() context.Context {
				md := metadata.Pairs("Token", "malformed.token.string")
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedUserID: 0,
			expectedError:  "invalid token: it's not even a token",
		},
		{
			name: "Missing Token in Context",
			setupContext: func() context.Context {
				return context.Background()
			},
			expectedUserID: 0,
			expectedError:  "no metadata in context",
		},
		{
			name: "Token with Invalid Claims Structure",
			setupContext: func() context.Context {
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
					"some_other_claim": "value",
				})
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.Pairs("Token", tokenString)
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedUserID: 0,
			expectedError:  "invalid token: cannot map token to claims",
		},
		{
			name: "Valid Token with Future NotBefore Claim",
			setupContext: func() context.Context {
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						NotBefore: time.Now().Add(time.Hour).Unix(),
						ExpiresAt: time.Now().Add(time.Hour * 2).Unix(),
					},
				})
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.Pairs("Token", tokenString)
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedUserID: 0,
			expectedError:  "invalid token: couldn't handle this token",
		},
		{
			name: "Valid Token with Incorrect Signing Method",
			setupContext: func() context.Context {
				token := jwt.NewWithClaims(jwt.SigningMethodHS512, &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				})
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.Pairs("Token", tokenString)
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedUserID: 0,
			expectedError:  "invalid token: couldn't handle this token",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := tt.setupContext()
			userID, err := GetUserID(ctx)

			if userID != tt.expectedUserID {
				t.Errorf("Expected UserID %d, got %d", tt.expectedUserID, userID)
			}

			if tt.expectedError == "" && err != nil {
				t.Errorf("Expected no error, got %v", err)
			} else if tt.expectedError != "" && err == nil {
				t.Errorf("Expected error %s, got nil", tt.expectedError)
			} else if tt.expectedError != "" && err != nil && err.Error() != tt.expectedError {
				t.Errorf("Expected error %s, got %v", tt.expectedError, err)
			}
		})
	}
}
