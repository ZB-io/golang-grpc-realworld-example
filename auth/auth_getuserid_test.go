// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Vertex AI and AI Model claude-3-5-sonnet-v2

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

 writing test scenarios for the GetUserID function. Here are comprehensive test scenarios:

```
Scenario 1: Valid Token with Valid Claims

Details:
  Description: Tests the successful extraction of a user ID from a valid JWT token with proper claims.
Execution:
  Arrange: 
    - Create a context with valid JWT token metadata
    - Set up claims with valid UserID and non-expired ExpiresAt
    - Configure JWT secret
  Act:
    - Call GetUserID with the prepared context
  Assert:
    - Verify returned UserID matches expected value
    - Confirm no error is returned
Validation:
  This test ensures the primary success path works correctly, validating that properly formatted and valid tokens return the correct UserID.

Scenario 2: Expired Token

Details:
  Description: Verifies proper handling of an expired JWT token.
Execution:
  Arrange:
    - Create a context with JWT token metadata
    - Set up claims with ExpiresAt timestamp in the past
  Act:
    - Call GetUserID with the context containing expired token
  Assert:
    - Verify returned UserID is 0
    - Confirm error message contains "token expired"
Validation:
  Essential for security, ensuring expired tokens are properly rejected.

Scenario 3: Malformed Token

Details:
  Description: Tests handling of malformed or invalid JWT token format.
Execution:
  Arrange:
    - Create context with invalid token string
  Act:
    - Call GetUserID with context containing malformed token
  Assert:
    - Verify returned UserID is 0
    - Confirm error message indicates invalid token format
Validation:
  Critical for security, ensuring the system properly rejects improperly formatted tokens.

Scenario 4: Missing Authentication Metadata

Details:
  Description: Tests behavior when no authentication metadata is present in context.
Execution:
  Arrange:
    - Create empty context without any auth metadata
  Act:
    - Call GetUserID with empty context
  Assert:
    - Verify returned UserID is 0
    - Confirm appropriate error from grpc_auth.AuthFromMD
Validation:
  Ensures proper handling of missing authentication data, important for API security.

Scenario 5: Invalid Claims Type

Details:
  Description: Tests handling of tokens with claims that don't match expected structure.
Execution:
  Arrange:
    - Create context with token containing invalid claims structure
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm error message about invalid claims mapping
Validation:
  Ensures robust handling of tokens with unexpected claims structure.

Scenario 6: Future Token (Not Yet Valid)

Details:
  Description: Tests handling of tokens with future validity timestamps.
Execution:
  Arrange:
    - Create context with token having future NotBefore claim
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm appropriate error about token not being valid yet
Validation:
  Important for security, ensuring tokens can't be used before their intended validity period.

Scenario 7: Invalid Signature

Details:
  Description: Tests handling of tokens with invalid signatures.
Execution:
  Arrange:
    - Create context with token signed with different secret
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm error indicating invalid signature
Validation:
  Critical security test ensuring tokens with invalid signatures are rejected.

Scenario 8: Zero UserID in Valid Token

Details:
  Description: Tests handling of valid token with zero UserID in claims.
Execution:
  Arrange:
    - Create context with valid token containing UserID of 0
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm no error is returned
Validation:
  Edge case testing to ensure proper handling of zero values in valid tokens.
```

These scenarios cover the main functionality paths, error conditions, and edge cases for the GetUserID function. They ensure proper token validation, claims handling, and error reporting while maintaining security requirements.
*/

// ********RoostGPT********
package auth

import (
    "context"
    "testing"
    "time"
    "github.com/dgrijalva/jwt-go"
    grpc_metadata "google.golang.org/grpc/metadata"
)

// claims structure for JWT token
type claims struct {
    UserID uint
    jwt.StandardClaims
}

// jwtSecret is the secret key used for signing JWT tokens
var jwtSecret = []byte("test-secret")

// TestGetUserID tests various scenarios for the GetUserID function
func TestGetUserID(t *testing.T) {
    tests := []struct {
        name          string
        setupContext  func() context.Context
        expectedID    uint
        expectedError string
    }{
        {
            name: "Valid Token with Valid Claims",
            setupContext: func() context.Context {
                claims := &claims{
                    UserID: 123,
                    StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour).Unix(),
                    },
                }
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
                tokenString, _ := token.SignedString(jwtSecret)
                md := grpc_metadata.Pairs("Token", tokenString)
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    123,
            expectedError: "",
        },
        {
            name: "Expired Token",
            setupContext: func() context.Context {
                claims := &claims{
                    UserID: 123,
                    StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(-time.Hour).Unix(),
                    },
                }
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
                tokenString, _ := token.SignedString(jwtSecret)
                md := grpc_metadata.Pairs("Token", tokenString)
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    0,
            expectedError: "token expired",
        },
        {
            name: "Malformed Token",
            setupContext: func() context.Context {
                md := grpc_metadata.Pairs("Token", "malformed.token.string")
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    0,
            expectedError: "invalid token: it's not even a token",
        },
        {
            name: "Missing Authentication Metadata",
            setupContext: func() context.Context {
                return context.Background()
            },
            expectedID:    0,
            expectedError: "metadata not found",
        },
        {
            name: "Invalid Claims Type",
            setupContext: func() context.Context {
                token := jwt.New(jwt.SigningMethodHS256)
                tokenString, _ := token.SignedString(jwtSecret)
                md := grpc_metadata.Pairs("Token", tokenString)
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    0,
            expectedError: "invalid token: cannot map token to claims",
        },
        {
            name: "Future Token",
            setupContext: func() context.Context {
                claims := &claims{
                    UserID: 123,
                    StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour).Unix(),
                        NotBefore: time.Now().Add(time.Hour).Unix(),
                    },
                }
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
                tokenString, _ := token.SignedString(jwtSecret)
                md := grpc_metadata.Pairs("Token", tokenString)
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    0,
            expectedError: "invalid token: couldn't handle this token",
        },
        {
            name: "Invalid Signature",
            setupContext: func() context.Context {
                claims := &claims{
                    UserID: 123,
                    StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour).Unix(),
                    },
                }
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
                tokenString, _ := token.SignedString([]byte("wrong-secret"))
                md := grpc_metadata.Pairs("Token", tokenString)
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    0,
            expectedError: "invalid token: couldn't handle this token",
        },
        {
            name: "Zero UserID in Valid Token",
            setupContext: func() context.Context {
                claims := &claims{
                    UserID: 0,
                    StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour).Unix(),
                    },
                }
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
                tokenString, _ := token.SignedString(jwtSecret)
                md := grpc_metadata.Pairs("Token", tokenString)
                return grpc_metadata.NewIncomingContext(context.Background(), md)
            },
            expectedID:    0,
            expectedError: "",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctx := tt.setupContext()
            gotID, err := GetUserID(ctx)

            if gotID != tt.expectedID {
                t.Errorf("GetUserID() got UserID = %v, want %v", gotID, tt.expectedID)
            }

            if tt.expectedError == "" {
                if err != nil {
                    t.Errorf("GetUserID() unexpected error = %v", err)
                }
            } else {
                if err == nil {
                    t.Errorf("GetUserID() expected error containing %q, got nil", tt.expectedError)
                } else if !contains(err.Error(), tt.expectedError) {
                    t.Errorf("GetUserID() expected error containing %q, got %q", tt.expectedError, err.Error())
                }
            }
        })
    }
}

// Helper function to check if a string contains another string
func contains(s, substr string) bool {
    return s != "" && substr != "" && s != substr && len(s) > len(substr) && s[:len(substr)] == substr
}
