// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Vertex AI and AI Model claude-3-5-sonnet-v2

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

 writing test scenarios for the GetUserID function. Here are comprehensive test scenarios:

```
Scenario 1: Valid Token with Valid Claims

Details:
  Description: Tests the successful extraction of a user ID from a valid JWT token with proper claims.
Execution:
  Arrange: 
    - Create a context with valid JWT token metadata
    - Set up claims with valid UserID and non-expired ExpiresAt
    - Configure JWT secret
  Act:
    - Call GetUserID with the prepared context
  Assert:
    - Verify returned UserID matches expected value
    - Confirm no error is returned
Validation:
  This test ensures the primary success path works correctly, validating that properly formatted and valid tokens return the correct UserID.

Scenario 2: Expired Token

Details:
  Description: Verifies proper handling of an expired JWT token.
Execution:
  Arrange:
    - Create a context with JWT token metadata
    - Set up claims with ExpiresAt timestamp in the past
  Act:
    - Call GetUserID with the context containing expired token
  Assert:
    - Verify returned UserID is 0
    - Confirm error message contains "token expired"
Validation:
  Essential for security, ensuring expired tokens are properly rejected.

Scenario 3: Malformed Token

Details:
  Description: Tests handling of malformed or invalid JWT token format.
Execution:
  Arrange:
    - Create context with invalid token string
  Act:
    - Call GetUserID with context containing malformed token
  Assert:
    - Verify returned UserID is 0
    - Confirm error message indicates invalid token format
Validation:
  Critical for security, ensuring the system properly rejects improperly formatted tokens.

Scenario 4: Missing Authentication Metadata

Details:
  Description: Tests behavior when no authentication metadata is present in context.
Execution:
  Arrange:
    - Create empty context without any auth metadata
  Act:
    - Call GetUserID with empty context
  Assert:
    - Verify returned UserID is 0
    - Confirm appropriate error from grpc_auth.AuthFromMD
Validation:
  Ensures proper handling of missing authentication data, important for API security.

Scenario 5: Invalid Claims Type

Details:
  Description: Tests handling of tokens with claims that don't match expected structure.
Execution:
  Arrange:
    - Create context with token containing invalid claims structure
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm error message about invalid claims mapping
Validation:
  Ensures robust handling of tokens with unexpected claims structure.

Scenario 6: Future Token (Not Yet Valid)

Details:
  Description: Tests handling of tokens with future validity timestamps.
Execution:
  Arrange:
    - Create context with token having future NotBefore claim
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm appropriate error about token not being valid yet
Validation:
  Important for security, ensuring tokens can't be used before their intended validity period.

Scenario 7: Invalid Signature

Details:
  Description: Tests handling of tokens with invalid signatures.
Execution:
  Arrange:
    - Create context with token signed with different secret
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm error indicating invalid signature
Validation:
  Critical security test ensuring tokens with invalid signatures are rejected.

Scenario 8: Zero UserID in Valid Token

Details:
  Description: Tests handling of valid token with zero UserID in claims.
Execution:
  Arrange:
    - Create context with valid token containing UserID of 0
  Act:
    - Call GetUserID with context
  Assert:
    - Verify returned UserID is 0
    - Confirm no error is returned
Validation:
  Edge case testing to ensure proper handling of zero values in valid tokens.
```

These scenarios cover the main functionality paths, error conditions, and edge cases for the GetUserID function. They ensure proper token validation, claims handling, and error reporting while maintaining security requirements.
*/

// ********RoostGPT********
package auth

import (
	"context"
	"testing"
	"time"
	
	"github.com/dgrijalva/jwt-go"
	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc/metadata"
)

// claims structure needed for the test
type claims struct {
	UserID uint `json:"user_id"`
	jwt.StandardClaims
}

// TestGetUserID tests various scenarios for the GetUserID function
func TestGetUserID(t *testing.T) {
	originalSecret := jwtSecret
	jwtSecret = []byte("test-secret")
	defer func() {
		jwtSecret = originalSecret
	}()

	tests := []struct {
		name          string
		setupContext  func() context.Context
		expectedID    uint
		expectedError string
	}{
		{
			name: "Valid Token with Valid Claims",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.New(map[string]string{
					"authorization": "Token " + tokenString,
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    123,
			expectedError: "",
		},
		{
			name: "Expired Token",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(-time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.New(map[string]string{
					"authorization": "Token " + tokenString,
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "token expired",
		},
		{
			name: "Malformed Token",
			setupContext: func() context.Context {
				md := metadata.New(map[string]string{
					"authorization": "Token invalid-token-string",
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token: it's not even a token",
		},
		{
			name: "Missing Authentication Metadata",
			setupContext: func() context.Context {
				return context.Background()
			},
			expectedID:    0,
			expectedError: "metadata not found",
		},
		{
			name: "Invalid Claims Type",
			setupContext: func() context.Context {
				token := jwt.New(jwt.SigningMethodHS256)
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.New(map[string]string{
					"authorization": "Token " + tokenString,
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token: cannot map token to claims",
		},
		{
			name: "Future Token",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
						NotBefore: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.New(map[string]string{
					"authorization": "Token " + tokenString,
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "token is not valid yet",
		},
		{
			name: "Invalid Signature",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString([]byte("wrong-secret"))
				md := metadata.New(map[string]string{
					"authorization": "Token " + tokenString,
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token",
		},
		{
			name: "Zero UserID in Valid Token",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 0,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := metadata.New(map[string]string{
					"authorization": "Token " + tokenString,
				})
				return metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := tt.setupContext()
			userID, err := GetUserID(ctx)

			if tt.expectedError != "" {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
				assert.Equal(t, tt.expectedID, userID)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedID, userID)
			}
		})
	}
}
