// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Vertex AI and AI Model claude-3-5-sonnet-v2

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

 tasked with writing test scenarios for the `GetUserID` function. Here are the test scenarios:

```
Scenario 1: Valid Token with Valid Claims

Details:
  Description: Test the successful extraction of a user ID from a valid JWT token with proper claims.
Execution:
  Arrange:
    - Create a context with valid JWT token in metadata
    - Set up claims with valid UserID and non-expired ExpiresAt
    - Configure JWT secret
  Act:
    - Call GetUserID with the prepared context
  Assert:
    - Expect returned UserID to match the one in claims
    - Expect no error to be returned
Validation:
    This test validates the happy path where all conditions are met correctly.
    It ensures the core functionality of extracting user ID from valid tokens works as expected.

Scenario 2: Missing Authentication Token

Details:
  Description: Test behavior when no token is present in the context metadata.
Execution:
  Arrange:
    - Create a context without any authentication metadata
  Act:
    - Call GetUserID with the empty context
  Assert:
    - Expect UserID to be 0
    - Expect an error indicating missing token
Validation:
    Validates proper error handling when authentication data is missing.
    Critical for security to ensure unauthenticated requests are properly rejected.

Scenario 3: Expired Token

Details:
  Description: Test handling of an expired JWT token.
Execution:
  Arrange:
    - Create context with JWT token
    - Set token ExpiresAt to past timestamp
  Act:
    - Call GetUserID with context containing expired token
  Assert:
    - Expect UserID to be 0
    - Expect "token expired" error
Validation:
    Ensures security by validating that expired tokens are properly detected and rejected.
    Critical for maintaining secure authentication state.

Scenario 4: Malformed Token

Details:
  Description: Test handling of malformed JWT token string.
Execution:
  Arrange:
    - Create context with invalid token string
  Act:
    - Call GetUserID with context containing malformed token
  Assert:
    - Expect UserID to be 0
    - Expect error indicating invalid token format
Validation:
    Validates proper handling of corrupted or invalid token strings.
    Important for security and robust error handling.

Scenario 5: Invalid Claims Structure

Details:
  Description: Test behavior when token claims cannot be properly mapped to claims struct.
Execution:
  Arrange:
    - Create context with JWT token containing incompatible claims structure
  Act:
    - Call GetUserID with context containing invalid claims
  Assert:
    - Expect UserID to be 0
    - Expect error about invalid claims mapping
Validation:
    Ensures robust handling of tokens with incorrect internal structure.
    Important for maintaining data integrity and security.

Scenario 6: Token Not Yet Valid

Details:
  Description: Test handling of tokens with future validity timestamp.
Execution:
  Arrange:
    - Create context with JWT token
    - Set token NotBefore claim to future timestamp
  Act:
    - Call GetUserID with context containing future token
  Assert:
    - Expect UserID to be 0
    - Expect validation error for future token
Validation:
    Validates proper handling of tokens that shouldn't be valid yet.
    Important for maintaining proper token lifecycle management.

Scenario 7: Invalid Signature

Details:
  Description: Test handling of tokens with invalid signatures.
Execution:
  Arrange:
    - Create context with JWT token signed with different secret
  Act:
    - Call GetUserID with context containing incorrectly signed token
  Assert:
    - Expect UserID to be 0
    - Expect signature validation error
Validation:
    Critical security test ensuring tokens with invalid signatures are rejected.
    Fundamental for maintaining JWT security guarantees.

Scenario 8: Zero UserID in Valid Token

Details:
  Description: Test handling of valid token with zero UserID in claims.
Execution:
  Arrange:
    - Create context with valid JWT token
    - Set UserID to 0 in claims
  Act:
    - Call GetUserID with context containing zero UserID
  Assert:
    - Expect UserID to be 0
    - Expect successful execution without error
Validation:
    Validates handling of edge case where UserID is zero but token is valid.
    Important for data integrity and proper ID handling.
```

These scenarios cover the main functionality paths, error conditions, and edge cases for the GetUserID function. They ensure proper handling of authentication, token validation, and error conditions while maintaining security and data integrity.
*/

// ********RoostGPT********
package auth

import (
	"context"
	"testing"
	"time"
	
	"github.com/dgrijalva/jwt-go"
	"github.com/stretchr/testify/assert"
	grpc_metadata "google.golang.org/grpc/metadata"
)

// TestGetUserID tests various scenarios for the GetUserID function
func TestGetUserID(t *testing.T) {
	// TODO: Update jwtSecret if different in production code
	jwtSecret = []byte("test-secret")

	tests := []struct {
		name          string
		setupContext  func() context.Context
		expectedID    uint
		expectedError string
	}{
		{
			name: "Valid Token with Valid Claims",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := grpc_metadata.Pairs("Token", tokenString)
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    123,
			expectedError: "",
		},
		{
			name: "Missing Authentication Token",
			setupContext: func() context.Context {
				return context.Background()
			},
			expectedID:    0,
			expectedError: "metadata not found",
		},
		{
			name: "Expired Token",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(-time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := grpc_metadata.Pairs("Token", tokenString)
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "token expired",
		},
		{
			name: "Malformed Token",
			setupContext: func() context.Context {
				md := grpc_metadata.Pairs("Token", "malformed.token.string")
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token: it's not even a token",
		},
		{
			name: "Invalid Claims Structure",
			setupContext: func() context.Context {
				token := jwt.New(jwt.SigningMethodHS256)
				tokenString, _ := token.SignedString(jwtSecret)
				md := grpc_metadata.Pairs("Token", tokenString)
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token: cannot map token to claims",
		},
		{
			name: "Token Not Yet Valid",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
						NotBefore: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := grpc_metadata.Pairs("Token", tokenString)
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token: couldn't handle this token",
		},
		{
			name: "Invalid Signature",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 123,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString([]byte("wrong-secret"))
				md := grpc_metadata.Pairs("Token", tokenString)
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "invalid token: couldn't handle this token",
		},
		{
			name: "Zero UserID in Valid Token",
			setupContext: func() context.Context {
				claims := &claims{
					UserID: 0,
					StandardClaims: jwt.StandardClaims{
						ExpiresAt: time.Now().Add(time.Hour).Unix(),
					},
				}
				token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
				tokenString, _ := token.SignedString(jwtSecret)
				md := grpc_metadata.Pairs("Token", tokenString)
				return grpc_metadata.NewIncomingContext(context.Background(), md)
			},
			expectedID:    0,
			expectedError: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Log("Testing scenario:", tt.name)
			
			ctx := tt.setupContext()
			userID, err := GetUserID(ctx)

			if tt.expectedError != "" {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
				assert.Equal(t, uint(0), userID)
				t.Logf("Expected error received: %v", err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedID, userID)
				t.Logf("Successfully retrieved UserID: %d", userID)
			}
		})
	}
}
