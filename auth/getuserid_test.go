// ********RoostGPT********
/*
Test generated by RoostGPT for test go-grpc-client using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=GetUserID_f2dd680cb2
ROOST_METHOD_SIG_HASH=GetUserID_e739312e3d

Scenario 1: Valid token and not expired
Details:
    Description: This test is meant to check if the GetUserID function properly fetches and parses the Claims from a valid and unexpired token.
Execution:
    Arrange: Pass valid context with an associated metadata containing JWT token in the correct format.
    Act: Invoke the GetUserID function with the appropriate context.
    Assert: Assert that the returned userID is correct, and no error is returned.
Validation:
    Given the context with valid token, the function should parse the token and return user ID without any error. The test ensures that the main functionality of the function works as expected.

Scenario 2: Invalid token return error
Details:
    Description: The test is meant to check if the GetUserID function properly handles invalid tokens and returns fitting error messages.
Execution:
    Arrange: Pass context with an associated metadata containing an incorrectly formatted JWT token.
    Act: Invoke the GetUserID function with the appropriate context.
    Assert: Assert that an error regarding the malformed token is returned.
Validation:
    Given the context with an invalid token, the function should return a fitting error. The test verifies the error handling capability of the GetUserID function.

Scenario 3: Valid token but expired
Details:
    Description: The test is meant to check if the GetUserID function can accurately catch and handle expired tokens.
Execution:
    Arrange: Pass context with an associated metadata containing a valid but expired JWT token.
    Act: Invoke the GetUserID function with the appropriate context.
    Assert: Assert that an error regarding the token's expiration is returned.
Validation:
    Given the context with an expired token, the function should timely return an error indicating the token is expired. This test case asserts the GetUserID functionâ€™s ability to validate token lifetimes.

Scenario 4: Token cannot be mapped to claims
Details:
    Description: This test is meant to check how the function handles tokens whose Claims cannot be mapped accurately.
Execution:
    Arrange: Pass context with an associated metadata containing a token whose Claims are formatted in a way that can't be mapped to 'claims' struct.
    Act: Invoke the GetUserID function with the appropriate context.
    Assert: Assert that an error regarding the token claims mapping is returned.
Validation:
    Given the context with a token that cannot be mapped to 'claims', the function should give proper error indicating that it couldn't map the token to claims. This test case ensures that the function can properly handle claims mapping issues.

Scenario 5: Error when fetching token from context
Details:
    Description: This test is meant to check how the function handles errors when trying to fetch token from context.
Execution:
    Arrange: Pass context without any associated metadata.
    Act: Invoke the GetUserID function with the appropriate context.
    Assert: Assert that an error regarding token fetching is returned.
Validation:
    Given the context without any token, the function should return error indicating problems with token fetching. This test case ensures that the function can properly handle issues related to fetching token from context.
*/

// ********RoostGPT********

package auth

import (
	"context"
	"errors"
	"github.com/dgrijalva/jwt-go"
	"github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

type claims struct {
	UserID uint
	jwt.StandardClaims
}

var jwtSecret = []byte("<YOUR_SIGNING_SECRET>")
var testClaims = &claims{
	UserID: 1234,
	StandardClaims: jwt.StandardClaims{
		ExpiresAt: time.Now().Add(time.Minute * 10).Unix(),
	},
}

func TestGetUserID(t *testing.T) {
	tests := []struct {
		name   string
		claims *claims
		want   uint
		err    error
	}{
		{
			name:   "valid token, not expired",
			claims: testClaims,
			want:   1234,
			err:    nil,
		},
		{
			name:   "invalid token",
			claims: nil,
			want:   0,
			err:    errors.New("missing or malformed jwt"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {

			token := createToken(t, tt.claims)

			ctx := context.WithValue(context.Background(), "Token", token)
			got, err := GetUserID(ctx)

			assert.Equal(t, tt.err, err)
			assert.Equal(t, tt.want, got)
		})
	}
}

func createToken(t *testing.T, claims *claims) string {
	if claims == nil {
		return ""
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	ss, err := token.SignedString(jwtSecret)
	if err != nil {
		t.Errorf("could not create token: %v", err)
	}
	return ss
}

func GetUserID(ctx context.Context) (uint, error) {
	tokenString, _ := auth.AuthFromMD(ctx, "bearer")

	if tokenString == "" {
		return 0, errors.New("missing or malformed jwt")
	}
	tokenClaims := &claims{}
	token, err := jwt.ParseWithClaims(tokenString, tokenClaims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})

	if err != nil || !token.Valid {
		return 0, errors.New("Invalid token")
	}
	return tokenClaims.UserID, nil
}


