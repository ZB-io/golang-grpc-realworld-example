// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UnfollowUser_843a2807ea
ROOST_METHOD_SIG_HASH=UnfollowUser_a64840f937

FUNCTION_DEF=func (h *Handler) UnfollowUser(ctx context.Context, req *pb.UnfollowRequest) (*pb.ProfileResponse, error)
Here are several test scenarios for the `UnfollowUser` function:

```
Scenario 1: Successful Unfollow

Details:
  Description: Test the successful unfollowing of a user by another user.
Execution:
  Arrange:
    - Create two users: currentUser and requestUser
    - Set up currentUser to be following requestUser
    - Mock auth.GetUserID to return currentUser's ID
    - Mock h.us.GetByID to return currentUser
    - Mock h.us.GetByUsername to return requestUser
    - Mock h.us.IsFollowing to return true
    - Mock h.us.Unfollow to succeed
  Act:
    - Call UnfollowUser with a valid context and UnfollowRequest containing requestUser's username
  Assert:
    - Expect a non-nil ProfileResponse
    - Expect no error
    - Verify that h.us.Unfollow was called with correct parameters
Validation:
  This test ensures the happy path works correctly, validating that a user can successfully unfollow another user they were following.

Scenario 2: Unauthenticated User

Details:
  Description: Test the behavior when an unauthenticated user tries to unfollow someone.
Execution:
  Arrange:
    - Mock auth.GetUserID to return an error
  Act:
    - Call UnfollowUser with a context and valid UnfollowRequest
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with Unauthenticated gRPC code
Validation:
  This test verifies that the function correctly handles unauthenticated requests, ensuring security measures are in place.

Scenario 3: Current User Not Found

Details:
  Description: Test the case where the current user is not found in the database.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid ID
    - Mock h.us.GetByID to return an error (user not found)
  Act:
    - Call UnfollowUser with a valid context and UnfollowRequest
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with NotFound gRPC code
Validation:
  This test ensures proper error handling when the current user cannot be retrieved from the database.

Scenario 4: Attempting to Unfollow Self

Details:
  Description: Test the case where a user attempts to unfollow themselves.
Execution:
  Arrange:
    - Create a user
    - Mock auth.GetUserID to return the user's ID
    - Mock h.us.GetByID to return the user
    - Set up the UnfollowRequest with the same username as the current user
  Act:
    - Call UnfollowUser with a valid context and the prepared UnfollowRequest
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with InvalidArgument gRPC code
Validation:
  This test verifies that the function prevents users from unfollowing themselves, which is a logical constraint of the system.

Scenario 5: Request User Not Found

Details:
  Description: Test the behavior when the user to be unfollowed doesn't exist.
Execution:
  Arrange:
    - Create a currentUser
    - Mock auth.GetUserID to return currentUser's ID
    - Mock h.us.GetByID to return currentUser
    - Mock h.us.GetByUsername to return an error (user not found)
  Act:
    - Call UnfollowUser with a valid context and UnfollowRequest containing a non-existent username
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with NotFound gRPC code
Validation:
  This test ensures proper error handling when attempting to unfollow a non-existent user.

Scenario 6: Not Following the User

Details:
  Description: Test the case where the current user attempts to unfollow a user they are not following.
Execution:
  Arrange:
    - Create currentUser and requestUser
    - Mock auth.GetUserID to return currentUser's ID
    - Mock h.us.GetByID to return currentUser
    - Mock h.us.GetByUsername to return requestUser
    - Mock h.us.IsFollowing to return false
  Act:
    - Call UnfollowUser with a valid context and UnfollowRequest
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with Unauthenticated gRPC code
Validation:
  This test verifies that users can't unfollow someone they're not already following, maintaining data integrity.

Scenario 7: Database Error During Unfollow

Details:
  Description: Test the behavior when a database error occurs during the unfollow operation.
Execution:
  Arrange:
    - Create currentUser and requestUser
    - Mock auth.GetUserID, h.us.GetByID, h.us.GetByUsername, and h.us.IsFollowing to succeed
    - Mock h.us.Unfollow to return an error
  Act:
    - Call UnfollowUser with a valid context and UnfollowRequest
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with Aborted gRPC code
Validation:
  This test ensures proper error handling when the database operation to unfollow fails, which is crucial for maintaining data consistency.
```

These test scenarios cover various aspects of the `UnfollowUser` function, including successful operation, authentication, data validation, and error handling. They aim to ensure the function behaves correctly under different conditions and maintains the integrity and security of the application.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/jinzhu/gorm"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestHandlerUnfollowUser(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*Handler)
		req            *pb.UnfollowRequest
		expectedResp   *pb.ProfileResponse
		expectedErrMsg string
		expectedCode   codes.Code
	}{
		{
			name: "Successful Unfollow",
			setupMocks: func(h *Handler) {
				currentUser := &model.User{Model: gorm.Model{ID: 1}, Username: "current"}
				requestUser := &model.User{Model: gorm.Model{ID: 2}, Username: "request"}
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.GetByID = func(id uint) (*model.User, error) {
					return currentUser, nil
				}
				h.us.GetByUsername = func(username string) (*model.User, error) {
					return requestUser, nil
				}
				h.us.IsFollowing = func(follower, followed *model.User) (bool, error) {
					return true, nil
				}
				h.us.Unfollow = func(follower, followed *model.User) error {
					return nil
				}
			},
			req:          &pb.UnfollowRequest{Username: "request"},
			expectedResp: &pb.ProfileResponse{Profile: &pb.Profile{}},
		},
		{
			name: "Unauthenticated User",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 0, errors.New("unauthenticated")
				}
			},
			req:            &pb.UnfollowRequest{Username: "request"},
			expectedErrMsg: "unauthenticated",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Current User Not Found",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.GetByID = func(id uint) (*model.User, error) {
					return nil, errors.New("user not found")
				}
			},
			req:            &pb.UnfollowRequest{Username: "request"},
			expectedErrMsg: "user not found",
			expectedCode:   codes.NotFound,
		},
		{
			name: "Attempting to Unfollow Self",
			setupMocks: func(h *Handler) {
				currentUser := &model.User{Model: gorm.Model{ID: 1}, Username: "current"}
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.GetByID = func(id uint) (*model.User, error) {
					return currentUser, nil
				}
			},
			req:            &pb.UnfollowRequest{Username: "current"},
			expectedErrMsg: "cannot follow yourself",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Request User Not Found",
			setupMocks: func(h *Handler) {
				currentUser := &model.User{Model: gorm.Model{ID: 1}, Username: "current"}
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.GetByID = func(id uint) (*model.User, error) {
					return currentUser, nil
				}
				h.us.GetByUsername = func(username string) (*model.User, error) {
					return nil, errors.New("user not found")
				}
			},
			req:            &pb.UnfollowRequest{Username: "nonexistent"},
			expectedErrMsg: "user was not found",
			expectedCode:   codes.NotFound,
		},
		{
			name: "Not Following the User",
			setupMocks: func(h *Handler) {
				currentUser := &model.User{Model: gorm.Model{ID: 1}, Username: "current"}
				requestUser := &model.User{Model: gorm.Model{ID: 2}, Username: "request"}
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.GetByID = func(id uint) (*model.User, error) {
					return currentUser, nil
				}
				h.us.GetByUsername = func(username string) (*model.User, error) {
					return requestUser, nil
				}
				h.us.IsFollowing = func(follower, followed *model.User) (bool, error) {
					return false, nil
				}
			},
			req:            &pb.UnfollowRequest{Username: "request"},
			expectedErrMsg: "you are not following the user",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Database Error During Unfollow",
			setupMocks: func(h *Handler) {
				currentUser := &model.User{Model: gorm.Model{ID: 1}, Username: "current"}
				requestUser := &model.User{Model: gorm.Model{ID: 2}, Username: "request"}
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.GetByID = func(id uint) (*model.User, error) {
					return currentUser, nil
				}
				h.us.GetByUsername = func(username string) (*model.User, error) {
					return requestUser, nil
				}
				h.us.IsFollowing = func(follower, followed *model.User) (bool, error) {
					return true, nil
				}
				h.us.Unfollow = func(follower, followed *model.User) error {
					return errors.New("database error")
				}
			},
			req:            &pb.UnfollowRequest{Username: "request"},
			expectedErrMsg: "failed to unfollow user",
			expectedCode:   codes.Aborted,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			h := &Handler{
				logger: zerolog.New(nil),
				us:     &store.UserStore{},
				as:     &store.ArticleStore{},
			}
			tt.setupMocks(h)

			resp, err := h.UnfollowUser(context.Background(), tt.req)

			if tt.expectedErrMsg != "" {
				if err == nil {
					t.Errorf("expected error, got nil")
					return
				}
				st, ok := status.FromError(err)
				if !ok {
					t.Errorf("expected gRPC status error, got %v", err)
					return
				}
				if st.Code() != tt.expectedCode {
					t.Errorf("expected error code %v, got %v", tt.expectedCode, st.Code())
				}
				if st.Message() != tt.expectedErrMsg {
					t.Errorf("expected error message %q, got %q", tt.expectedErrMsg, st.Message())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
					return
				}
				if resp == nil {
					t.Errorf("expected non-nil response, got nil")
				}
				// TODO: Add more specific assertions for the response if needed
			}
		})
	}
}
