// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UnfavoriteArticle_47bfda8100
ROOST_METHOD_SIG_HASH=UnfavoriteArticle_9043d547fd

FUNCTION_DEF=func (h *Handler) UnfavoriteArticle(ctx context.Context, req *pb.UnfavoriteArticleRequest) (*pb.ArticleResponse, error)
Based on the provided function and context, here are several test scenarios for the `UnfavoriteArticle` function:

```
Scenario 1: Successfully Unfavorite an Article

Details:
  Description: This test verifies that a user can successfully unfavorite an article they previously favorited.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore with a valid user
    - Create a mock ArticleStore with an existing article that the user has favorited
    - Prepare a valid UnfavoriteArticleRequest with a valid article slug
  Act:
    - Call UnfavoriteArticle with the prepared context and request
  Assert:
    - Verify that the returned ArticleResponse is not nil
    - Check that the returned Article has Favorited set to false
    - Ensure FavoritesCount has decreased by 1
Validation:
  This test is crucial to ensure the core functionality of unfavoriting an article works correctly. It validates that the system properly updates the article's favorite status and count when a user unfavorites it.

Scenario 2: Attempt to Unfavorite an Article with Unauthenticated User

Details:
  Description: This test checks the function's behavior when an unauthenticated user attempts to unfavorite an article.
Execution:
  Arrange:
    - Set up a mock context that will fail authentication
    - Prepare a valid UnfavoriteArticleRequest
  Act:
    - Call UnfavoriteArticle with the unauthenticated context and request
  Assert:
    - Verify that the function returns an error
    - Ensure the error code is codes.Unauthenticated
Validation:
  This test is important to verify that the function properly handles authentication and prevents unauthorized access to the unfavorite functionality.

Scenario 3: Attempt to Unfavorite a Non-existent Article

Details:
  Description: This test verifies the function's behavior when trying to unfavorite an article that doesn't exist.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore with a valid user
    - Create a mock ArticleStore that returns an error when GetByID is called
    - Prepare an UnfavoriteArticleRequest with a non-existent article slug
  Act:
    - Call UnfavoriteArticle with the prepared context and request
  Assert:
    - Verify that the function returns an error
    - Ensure the error code is codes.InvalidArgument
Validation:
  This test ensures that the function handles invalid article IDs gracefully and returns an appropriate error message.

Scenario 4: Unfavorite an Article with Invalid Slug Format

Details:
  Description: This test checks the function's response when given a slug that cannot be converted to an integer.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore with a valid user
    - Prepare an UnfavoriteArticleRequest with an invalid slug (e.g., "not-a-number")
  Act:
    - Call UnfavoriteArticle with the prepared context and request
  Assert:
    - Verify that the function returns an error
    - Ensure the error code is codes.InvalidArgument
Validation:
  This test is important to verify that the function properly handles and reports errors related to invalid input formats.

Scenario 5: Attempt to Unfavorite an Article That Wasn't Favorited

Details:
  Description: This test verifies the function's behavior when a user tries to unfavorite an article they haven't favorited.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore with a valid user
    - Create a mock ArticleStore with an existing article that the user has not favorited
    - Prepare a valid UnfavoriteArticleRequest
  Act:
    - Call UnfavoriteArticle with the prepared context and request
  Assert:
    - Verify that the function returns an error
    - Ensure the error code is codes.InvalidArgument
    - Check that the error message indicates the article wasn't favorited
Validation:
  This test ensures that the function handles the edge case of unfavoriting an article that wasn't favorited, preventing inconsistent data states.

Scenario 6: Verify Following Status is Correctly Set in Response

Details:
  Description: This test checks if the following status of the article's author is correctly set in the response.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore with a valid user
    - Create a mock ArticleStore with an existing article
    - Set up the UserStore to return a specific following status
    - Prepare a valid UnfavoriteArticleRequest
  Act:
    - Call UnfavoriteArticle with the prepared context and request
  Assert:
    - Verify that the returned ArticleResponse is not nil
    - Check that the Author field in the response has the correct Following status
Validation:
  This test is important to ensure that the function correctly retrieves and sets the following status of the article's author, which is crucial for the front-end to display accurate user relationships.
```

These test scenarios cover various aspects of the `UnfavoriteArticle` function, including successful operation, authentication, error handling for invalid inputs, and edge cases. They aim to ensure the function behaves correctly under different conditions and maintains data integrity.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
)

// MockUserStore is a mock of UserStore interface
type MockUserStore struct {
	mock.Mock
}

func (m *MockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserStore) IsFollowing(a *model.User, b *model.User) (bool, error) {
	args := m.Called(a, b)
	return args.Bool(0), args.Error(1)
}

// MockArticleStore is a mock of ArticleStore interface
type MockArticleStore struct {
	mock.Mock
}

func (m *MockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *MockArticleStore) DeleteFavorite(a *model.Article, u *model.User) error {
	args := m.Called(a, u)
	return args.Error(0)
}

func TestHandlerUnfavoriteArticle(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*MockUserStore, *MockArticleStore)
		setupAuth      func(context.Context) context.Context
		input          *pb.UnfavoriteArticleRequest
		expectedOutput *pb.ArticleResponse
		expectedError  error
	}{
		{
			name: "Successfully Unfavorite an Article",
			setupMocks: func(us *MockUserStore, as *MockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, Slug: "1", FavoritesCount: 1}, nil)
				as.On("DeleteFavorite", mock.AnythingOfType("*model.Article"), mock.AnythingOfType("*model.User")).Return(nil)
				us.On("IsFollowing", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(false, nil)
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, 1)
			},
			input: &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedOutput: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:           "1",
					Favorited:      false,
					FavoritesCount: 0,
					Author:         &pb.Profile{Following: false},
				},
			},
			expectedError: nil,
		},
		{
			name:       "Attempt to Unfavorite an Article with Unauthenticated User",
			setupMocks: func(us *MockUserStore, as *MockArticleStore) {},
			setupAuth: func(ctx context.Context) context.Context {
				return ctx
			},
			input:          &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Attempt to Unfavorite a Non-existent Article",
			setupMocks: func(us *MockUserStore, as *MockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(nil, errors.New("article not found"))
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, 1)
			},
			input:          &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Unfavorite an Article with Invalid Slug Format",
			setupMocks: func(us *MockUserStore, as *MockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, 1)
			},
			input:          &pb.UnfavoriteArticleRequest{Slug: "not-a-number"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Attempt to Unfavorite an Article That Wasn't Favorited",
			setupMocks: func(us *MockUserStore, as *MockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, Slug: "1"}, nil)
				as.On("DeleteFavorite", mock.AnythingOfType("*model.Article"), mock.AnythingOfType("*model.User")).Return(errors.New("article not favorited"))
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, 1)
			},
			input:          &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "failed to remove favorite"),
		},
		{
			name: "Verify Following Status is Correctly Set in Response",
			setupMocks: func(us *MockUserStore, as *MockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, Slug: "1", Author: model.User{ID: 2}}, nil)
				as.On("DeleteFavorite", mock.AnythingOfType("*model.Article"), mock.AnythingOfType("*model.User")).Return(nil)
				us.On("IsFollowing", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(true, nil)
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, 1)
			},
			input: &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedOutput: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:      "1",
					Favorited: false,
					Author:    &pb.Profile{Following: true},
				},
			},
			expectedError: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUserStore := new(MockUserStore)
			mockArticleStore := new(MockArticleStore)
			tt.setupMocks(mockUserStore, mockArticleStore)

			h := &Handler{
				us: mockUserStore,
				as: mockArticleStore,
			}

			ctx := tt.setupAuth(context.Background())
			result, err := h.UnfavoriteArticle(ctx, tt.input)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedOutput, result)
			}

			mockUserStore.AssertExpectations(t)
			mockArticleStore.AssertExpectations(t)
		})
	}
}
