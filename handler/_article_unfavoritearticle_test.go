// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UnfavoriteArticle_47bfda8100
ROOST_METHOD_SIG_HASH=UnfavoriteArticle_9043d547fd

FUNCTION_DEF=func (h *Handler) UnfavoriteArticle(ctx context.Context, req *pb.UnfavoriteArticleRequest) (*pb.ArticleResponse, error)
Based on the provided function and context, here are several test scenarios for the `UnfavoriteArticle` function:

```
Scenario 1: Successful Unfavoriting of an Article

Details:
  Description: This test verifies that a user can successfully unfavorite an article when all conditions are met.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns a valid article
    - Set up the article to be initially favorited by the user
  Act:
    - Call UnfavoriteArticle with a valid request containing the article's slug
  Assert:
    - Verify that the returned ArticleResponse contains the correct article data
    - Check that the Favorited field in the returned article is set to false
    - Ensure that no error is returned
Validation:
  This test is crucial to ensure the core functionality of unfavoriting an article works as expected. It validates that the system correctly updates the favorite status and returns the updated article information.

Scenario 2: Unauthenticated User Attempt

Details:
  Description: This test checks the behavior when an unauthenticated user tries to unfavorite an article.
Execution:
  Arrange:
    - Set up a mock context that fails to provide a valid user ID
  Act:
    - Call UnfavoriteArticle with any valid request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that the returned error has the Unauthenticated gRPC code
Validation:
  This test is important to ensure that the function properly handles authentication and prevents unauthorized access to the unfavorite functionality.

Scenario 3: Valid Token but Non-existent User

Details:
  Description: This test verifies the behavior when a valid token is provided, but the corresponding user doesn't exist in the system.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that fails to find the user
  Act:
    - Call UnfavoriteArticle with a valid request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that the returned error has the NotFound gRPC code
Validation:
  This test ensures that the system correctly handles cases where a token might be valid but the user data is inconsistent, preventing potential security issues.

Scenario 4: Invalid Article Slug

Details:
  Description: This test checks the function's behavior when provided with an invalid article slug that can't be converted to an integer.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
  Act:
    - Call UnfavoriteArticle with a request containing an invalid slug (e.g., "not-a-number")
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that the returned error has the InvalidArgument gRPC code
Validation:
  This test is important to ensure that the function properly validates input and handles cases where the article identifier is malformed.

Scenario 5: Non-existent Article

Details:
  Description: This test verifies the behavior when trying to unfavorite an article that doesn't exist in the system.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that fails to find the article
  Act:
    - Call UnfavoriteArticle with a request containing a valid but non-existent article ID
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that the returned error has the InvalidArgument gRPC code
Validation:
  This test ensures that the system correctly handles attempts to unfavorite non-existent articles, preventing potential data inconsistencies.

Scenario 6: Failure to Remove Favorite

Details:
  Description: This test checks the behavior when the article service fails to remove the favorite status.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock services that return valid user and article data
    - Configure the mock article service to fail when calling DeleteFavorite
  Act:
    - Call UnfavoriteArticle with a valid request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that the returned error has the InvalidArgument gRPC code
Validation:
  This test is crucial to ensure that the system properly handles and reports errors that may occur during the unfavoriting process.

Scenario 7: Failure to Get Following Status

Details:
  Description: This test verifies the behavior when the system fails to determine if the current user is following the article's author.
Execution:
  Arrange:
    - Set up mock services that successfully handle all steps up to checking the following status
    - Configure the mock user service to fail when calling IsFollowing
  Act:
    - Call UnfavoriteArticle with a valid request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that the returned error has the NotFound gRPC code and mentions "internal server error"
Validation:
  This test ensures that the system gracefully handles errors in retrieving related user data and provides appropriate error responses.
```

These test scenarios cover a range of normal operations, edge cases, and error handling situations for the `UnfavoriteArticle` function. They aim to validate the function's behavior under various conditions, ensuring robust and correct implementation.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
)

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) DeleteFavorite(article *model.Article, user *model.User) error {
	args := m.Called(article, user)
	return args.Error(0)
}

func TestUnfavoriteArticle(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*mockUserStore, *mockArticleStore)
		req            *pb.UnfavoriteArticleRequest
		expectedResp   *pb.ArticleResponse
		expectedErrMsg string
		expectedCode   codes.Code
	}{
		{
			name: "Successful Unfavoriting of an Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 2}}, nil)
				as.On("DeleteFavorite", mock.Anything, mock.Anything).Return(nil)
				us.On("IsFollowing", mock.Anything, mock.Anything).Return(false, nil)
			},
			req: &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedResp: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:      "1",
					Favorited: false,
					Author:    &pb.Profile{Following: false},
				},
			},
		},
		{
			name:           "Unauthenticated User Attempt",
			setupMocks:     func(us *mockUserStore, as *mockArticleStore) {},
			req:            &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedErrMsg: "unauthenticated",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Valid Token but Non-existent User",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return((*model.User)(nil), errors.New("user not found"))
			},
			req:            &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedErrMsg: "not user found",
			expectedCode:   codes.NotFound,
		},
		{
			name: "Invalid Article Slug",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
			},
			req:            &pb.UnfavoriteArticleRequest{Slug: "not-a-number"},
			expectedErrMsg: "invalid article id",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Non-existent Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(999)).Return((*model.Article)(nil), errors.New("article not found"))
			},
			req:            &pb.UnfavoriteArticleRequest{Slug: "999"},
			expectedErrMsg: "invalid article id",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Failure to Remove Favorite",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1}, nil)
				as.On("DeleteFavorite", mock.Anything, mock.Anything).Return(errors.New("failed to remove favorite"))
			},
			req:            &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedErrMsg: "failed to remove favorite",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Failure to Get Following Status",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 2}}, nil)
				as.On("DeleteFavorite", mock.Anything, mock.Anything).Return(nil)
				us.On("IsFollowing", mock.Anything, mock.Anything).Return(false, errors.New("failed to get following status"))
			},
			req:            &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedErrMsg: "internal server error",
			expectedCode:   codes.NotFound,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUS := new(mockUserStore)
			mockAS := new(mockArticleStore)
			tt.setupMocks(mockUS, mockAS)

			h := &Handler{
				us: &store.UserStore{UserStorer: mockUS},
				as: &store.ArticleStore{ArticleStorer: mockAS},
			}

			ctx := context.WithValue(context.Background(), auth.UserIDKey, uint(1))
			resp, err := h.UnfavoriteArticle(ctx, tt.req)

			if tt.expectedErrMsg != "" {
				assert.Error(t, err)
				st, ok := status.FromError(err)
				assert.True(t, ok)
				assert.Equal(t, tt.expectedCode, st.Code())
				assert.Contains(t, st.Message(), tt.expectedErrMsg)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedResp, resp)
			}

			mockUS.AssertExpectations(t)
			mockAS.AssertExpectations(t)
		})
	}
}
