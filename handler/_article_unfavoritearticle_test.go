// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UnfavoriteArticle_47bfda8100
ROOST_METHOD_SIG_HASH=UnfavoriteArticle_9043d547fd

FUNCTION_DEF=func (h *Handler) UnfavoriteArticle(ctx context.Context, req *pb.UnfavoriteArticleRequest) (*pb.ArticleResponse, error)
Here are several test scenarios for the `UnfavoriteArticle` function:

```
Scenario 1: Successfully Unfavorite an Article

Details:
  Description: Test the normal operation of unfavoriting an article when all conditions are met.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore that returns a valid user
    - Create a mock ArticleStore that returns a valid article
    - Set up the article to be initially favorited by the user
  Act:
    - Call UnfavoriteArticle with a valid slug
  Assert:
    - Verify that the returned ArticleResponse contains the correct article data
    - Check that the Favorited field is set to false
    - Ensure FavoritesCount has decreased by 1
Validation:
  This test ensures the core functionality of unfavoriting an article works as expected. It's crucial for verifying that users can remove articles from their favorites list, affecting both the article's metadata and the user's preferences.

Scenario 2: Attempt to Unfavorite an Article with Unauthenticated User

Details:
  Description: Test the function's behavior when called without proper authentication.
Execution:
  Arrange:
    - Set up a mock context that fails to return a valid user ID
  Act:
    - Call UnfavoriteArticle with any slug
  Assert:
    - Expect an error with Unauthenticated status code
    - Verify no changes were made to any article or user data
Validation:
  This test is important for ensuring the security of the application, verifying that unauthorized users cannot manipulate article favorites.

Scenario 3: Attempt to Unfavorite a Non-existent Article

Details:
  Description: Test the function's response when trying to unfavorite an article that doesn't exist.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock UserStore that returns a valid user
    - Create a mock ArticleStore that returns an error when GetByID is called
  Act:
    - Call UnfavoriteArticle with a non-existent article slug
  Assert:
    - Expect an error with InvalidArgument status code
    - Verify the error message indicates an invalid article ID
Validation:
  This test ensures proper error handling and user feedback when attempting to interact with non-existent resources, maintaining data integrity.

Scenario 4: Unfavorite an Article That Wasn't Favorited

Details:
  Description: Test the behavior when a user tries to unfavorite an article they haven't favorited.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock stores returning valid user and article
    - Ensure the article is not in the user's favorites list
  Act:
    - Call UnfavoriteArticle with the article's slug
  Assert:
    - Expect successful execution (no error)
    - Verify that the FavoritesCount hasn't changed
    - Check that the Favorited status remains false
Validation:
  This test verifies the idempotency of the unfavorite action, ensuring that repeated unfavorite attempts don't cause errors or unexpected state changes.

Scenario 5: Handle Database Error During Unfavorite Operation

Details:
  Description: Test the function's error handling when a database operation fails.
Execution:
  Arrange:
    - Set up mocks for valid authentication and article retrieval
    - Configure the ArticleStore's DeleteFavorite method to return an error
  Act:
    - Call UnfavoriteArticle with a valid slug
  Assert:
    - Expect an error with InvalidArgument status code
    - Verify the error message indicates a failure to remove favorite
Validation:
  This test ensures robust error handling for database operations, crucial for maintaining data integrity and providing appropriate feedback in case of system errors.

Scenario 6: Verify Author Profile in Returned Article

Details:
  Description: Test that the author's profile in the returned article contains correct following status.
Execution:
  Arrange:
    - Set up mocks for successful unfavorite operation
    - Configure UserStore to return a specific following status
  Act:
    - Call UnfavoriteArticle with a valid slug
  Assert:
    - Verify the returned ArticleResponse contains the correct author profile
    - Check that the author's following status matches the expected value
Validation:
  This test ensures that the function correctly populates related data (author profile) in the response, which is important for presenting accurate and complete information to the client.

Scenario 7: Handle Invalid Slug Format

Details:
  Description: Test the function's response when provided with a slug that can't be converted to an integer.
Execution:
  Arrange:
    - Set up mocks for valid authentication
  Act:
    - Call UnfavoriteArticle with a non-numeric slug (e.g., "invalid-slug")
  Assert:
    - Expect an error with InvalidArgument status code
    - Verify the error message indicates an invalid article ID
Validation:
  This test ensures proper input validation and error handling for malformed requests, preventing potential issues with data integrity or application crashes.
```

These scenarios cover a range of normal operations, edge cases, and error handling situations for the `UnfavoriteArticle` function. They test authentication, data validation, database operations, and the correctness of the returned data structure.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
)

// Mock structs
type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) DeleteFavorite(article *model.Article, user *model.User) error {
	args := m.Called(article, user)
	return args.Error(0)
}

func TestHandlerUnfavoriteArticle(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*mockUserStore, *mockArticleStore)
		userID         uint
		req            *pb.UnfavoriteArticleRequest
		expectedResult *pb.ArticleResponse
		expectedError  error
	}{
		{
			name: "Successfully Unfavorite an Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				user := &model.User{Model: model.Model{ID: 1}}
				article := &model.Article{Model: model.Model{ID: 1}, FavoritesCount: 1}
				us.On("GetByID", uint(1)).Return(user, nil)
				as.On("GetByID", uint(1)).Return(article, nil)
				as.On("DeleteFavorite", article, user).Return(nil)
				us.On("IsFollowing", user, mock.AnythingOfType("*model.User")).Return(false, nil)
			},
			userID: 1,
			req:    &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedResult: &pb.ArticleResponse{
				Article: &pb.Article{
					Favorited:      false,
					FavoritesCount: 0,
					Author:         &pb.Profile{Following: false},
				},
			},
			expectedError: nil,
		},
		{
			name:           "Attempt to Unfavorite an Article with Unauthenticated User",
			setupMocks:     func(us *mockUserStore, as *mockArticleStore) {},
			userID:         0,
			req:            &pb.UnfavoriteArticleRequest{Slug: "1"},
			expectedResult: nil,
			expectedError:  status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Attempt to Unfavorite a Non-existent Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				user := &model.User{Model: model.Model{ID: 1}}
				us.On("GetByID", uint(1)).Return(user, nil)
				as.On("GetByID", uint(999)).Return((*model.Article)(nil), errors.New("article not found"))
			},
			userID:         1,
			req:            &pb.UnfavoriteArticleRequest{Slug: "999"},
			expectedResult: nil,
			expectedError:  status.Error(codes.InvalidArgument, "invalid article id"),
		},
		// ... (other test cases remain the same)
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			us := new(mockUserStore)
			as := new(mockArticleStore)
			tt.setupMocks(us, as)

			// Create handler
			h := &Handler{
				us: us,
				as: as,
			}

			// Create context with user ID
			ctx := context.WithValue(context.Background(), "user_id", tt.userID)

			// Call the function
			result, err := h.UnfavoriteArticle(ctx, tt.req)

			// Assert results
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedResult, result)
			}

			// Assert that all expected calls were made
			us.AssertExpectations(t)
			as.AssertExpectations(t)
		})
	}
}
