// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=FollowUser_36d65b5263
ROOST_METHOD_SIG_HASH=FollowUser_bf8ceb04bb

FUNCTION_DEF=func (h *Handler) FollowUser(ctx context.Context, req *pb.FollowRequest) (*pb.ProfileResponse, error)
Here are the test scenarios for the `FollowUser` function:

```
Scenario 1: Successfully Follow a User

Details:
  Description: Test the successful execution of following a user when all conditions are met.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with two users: currentUser and requestUser
    - Configure UserStore.GetByID to return currentUser
    - Configure UserStore.GetByUsername to return requestUser
    - Configure UserStore.Follow to succeed
  Act:
    - Call FollowUser with the context and a valid FollowRequest
  Assert:
    - Verify that the returned ProfileResponse contains the correct profile
    - Check that the returned error is nil
Validation:
  This test ensures that the core functionality of following a user works as expected under normal conditions. It's crucial for verifying the happy path of the feature.

Scenario 2: Attempt to Follow Oneself

Details:
  Description: Verify that a user cannot follow themselves.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with a single user
    - Configure UserStore.GetByID to return the user
    - Configure UserStore.GetByUsername to return the same user
  Act:
    - Call FollowUser with the context and a FollowRequest containing the user's own username
  Assert:
    - Verify that the returned error is a gRPC error with InvalidArgument code
    - Check that the error message contains "cannot follow yourself"
Validation:
  This test is important to prevent logical errors in the application, ensuring users can't follow themselves, which would be meaningless in a social context.

Scenario 3: Follow Non-existent User

Details:
  Description: Test the behavior when attempting to follow a user that doesn't exist.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with a currentUser
    - Configure UserStore.GetByID to return currentUser
    - Configure UserStore.GetByUsername to return an error (user not found)
  Act:
    - Call FollowUser with the context and a FollowRequest containing a non-existent username
  Assert:
    - Verify that the returned error is a gRPC error with NotFound code
    - Check that the error message indicates the user was not found
Validation:
  This test ensures proper error handling when dealing with non-existent users, which is crucial for maintaining data integrity and providing clear feedback to the client.

Scenario 4: Unauthenticated User Attempt

Details:
  Description: Verify that an unauthenticated user cannot follow another user.
Execution:
  Arrange:
    - Create a mock context that fails authentication
    - Configure auth.GetUserID to return an error
  Act:
    - Call FollowUser with the invalid context and a valid FollowRequest
  Assert:
    - Verify that the returned error is a gRPC error with Unauthenticated code
Validation:
  This test is critical for ensuring the security of the application by preventing unauthorized actions.

Scenario 5: Database Error During Follow Operation

Details:
  Description: Test the error handling when a database error occurs during the follow operation.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with currentUser and requestUser
    - Configure UserStore.GetByID and UserStore.GetByUsername to return successfully
    - Configure UserStore.Follow to return an error
  Act:
    - Call FollowUser with the context and a valid FollowRequest
  Assert:
    - Verify that the returned error is a gRPC error with Aborted code
    - Check that the error message indicates a failure to follow the user
Validation:
  This test ensures robust error handling for database operations, which is crucial for maintaining data consistency and providing appropriate feedback to the client.

Scenario 6: Already Following User

Details:
  Description: Verify the behavior when a user attempts to follow someone they're already following.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with currentUser and requestUser
    - Configure UserStore.GetByID and UserStore.GetByUsername to return successfully
    - Configure UserStore.Follow to simulate an already-following scenario (implementation-specific)
  Act:
    - Call FollowUser with the context and a FollowRequest for an already-followed user
  Assert:
    - Verify the returned ProfileResponse indicates the user is being followed
    - Check that no error is returned (assuming the function treats this as a successful operation)
Validation:
  This test ensures idempotency of the follow operation, which is important for consistent behavior in repeated API calls.

```

These test scenarios cover a range of normal operations, edge cases, and error handling situations for the `FollowUser` function. They aim to validate the function's behavior under various conditions, ensuring robustness and correctness of the implementation.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gorm.io/gorm"
)

// MockUserStore is a mock of UserStore interface
type MockUserStore struct {
	mock.Mock
}

func (m *MockUserStore) GetByID(id uint) (*store.User, error) {
	args := m.Called(id)
	return args.Get(0).(*store.User), args.Error(1)
}

func (m *MockUserStore) GetByUsername(username string) (*store.User, error) {
	args := m.Called(username)
	return args.Get(0).(*store.User), args.Error(1)
}

func (m *MockUserStore) Follow(a, b *store.User) error {
	args := m.Called(a, b)
	return args.Error(0)
}

func TestHandlerFollowUser(t *testing.T) {
	tests := []struct {
		name            string
		setupMocks      func(*MockUserStore)
		userID          uint
		authError       error
		req             *proto.FollowRequest
		expectedProfile *proto.Profile
		expectedError   error
	}{
		{
			name: "Successfully Follow a User",
			setupMocks: func(us *MockUserStore) {
				us.On("GetByID", uint(1)).Return(&store.User{ID: 1, Username: "currentUser"}, nil)
				us.On("GetByUsername", "requestUser").Return(&store.User{ID: 2, Username: "requestUser"}, nil)
				us.On("Follow", mock.AnythingOfType("*store.User"), mock.AnythingOfType("*store.User")).Return(nil)
			},
			userID:    1,
			authError: nil,
			req:       &proto.FollowRequest{Username: "requestUser"},
			expectedProfile: &proto.Profile{
				Username:  "requestUser",
				Following: true,
			},
			expectedError: nil,
		},
		{
			name: "Attempt to Follow Oneself",
			setupMocks: func(us *MockUserStore) {
				us.On("GetByID", uint(1)).Return(&store.User{ID: 1, Username: "currentUser"}, nil)
			},
			userID:          1,
			authError:       nil,
			req:             &proto.FollowRequest{Username: "currentUser"},
			expectedProfile: nil,
			expectedError:   status.Error(codes.InvalidArgument, "cannot follow yourself"),
		},
		{
			name: "Follow Non-existent User",
			setupMocks: func(us *MockUserStore) {
				us.On("GetByID", uint(1)).Return(&store.User{ID: 1, Username: "currentUser"}, nil)
				us.On("GetByUsername", "nonExistentUser").Return((*store.User)(nil), gorm.ErrRecordNotFound)
			},
			userID:          1,
			authError:       nil,
			req:             &proto.FollowRequest{Username: "nonExistentUser"},
			expectedProfile: nil,
			expectedError:   status.Error(codes.NotFound, "user was not found"),
		},
		{
			name:            "Unauthenticated User Attempt",
			setupMocks:      func(us *MockUserStore) {},
			userID:          0,
			authError:       errors.New("unauthenticated"),
			req:             &proto.FollowRequest{Username: "requestUser"},
			expectedProfile: nil,
			expectedError:   status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Database Error During Follow Operation",
			setupMocks: func(us *MockUserStore) {
				us.On("GetByID", uint(1)).Return(&store.User{ID: 1, Username: "currentUser"}, nil)
				us.On("GetByUsername", "requestUser").Return(&store.User{ID: 2, Username: "requestUser"}, nil)
				us.On("Follow", mock.AnythingOfType("*store.User"), mock.AnythingOfType("*store.User")).Return(errors.New("database error"))
			},
			userID:          1,
			authError:       nil,
			req:             &proto.FollowRequest{Username: "requestUser"},
			expectedProfile: nil,
			expectedError:   status.Error(codes.Aborted, "failed to follow user"),
		},
		{
			name: "Already Following User",
			setupMocks: func(us *MockUserStore) {
				us.On("GetByID", uint(1)).Return(&store.User{ID: 1, Username: "currentUser"}, nil)
				us.On("GetByUsername", "requestUser").Return(&store.User{ID: 2, Username: "requestUser"}, nil)
				us.On("Follow", mock.AnythingOfType("*store.User"), mock.AnythingOfType("*store.User")).Return(nil)
			},
			userID:    1,
			authError: nil,
			req:       &proto.FollowRequest{Username: "requestUser"},
			expectedProfile: &proto.Profile{
				Username:  "requestUser",
				Following: true,
			},
			expectedError: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mock UserStore
			mockUS := new(MockUserStore)
			tt.setupMocks(mockUS)

			// Create a mock context
			ctx := context.Background()
			ctx = context.WithValue(ctx, auth.UserIDKey, tt.userID)

			// Mock the auth.GetUserID function
			auth.GetUserID = func(ctx context.Context) (uint, error) {
				return tt.userID, tt.authError
			}

			// Create a Handler instance with the mock UserStore
			h := &Handler{
				logger: zerolog.Nop(),
				us:     mockUS,
			}

			// Call the FollowUser function
			resp, err := h.FollowUser(ctx, tt.req)

			// Check the error
			if tt.expectedError != nil {
				if err == nil {
					t.Fatalf("expected error %v, got nil", tt.expectedError)
				}
				if err.Error() != tt.expectedError.Error() {
					t.Errorf("expected error %v, got %v", tt.expectedError, err)
				}
			} else if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			// Check the response
			if tt.expectedProfile != nil {
				if resp == nil {
					t.Fatal("expected non-nil response, got nil")
				}
				if resp.Profile.Username != tt.expectedProfile.Username {
					t.Errorf("expected username %s, got %s", tt.expectedProfile.Username, resp.Profile.Username)
				}
				if resp.Profile.Following != tt.expectedProfile.Following {
					t.Errorf("expected following %v, got %v", tt.expectedProfile.Following, resp.Profile.Following)
				}
			} else if resp != nil {
				t.Errorf("expected nil response, got %v", resp)
			}

			// Assert that all expected mock calls were made
			mockUS.AssertExpectations(t)
		})
	}
}
