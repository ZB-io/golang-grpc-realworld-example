// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=FollowUser_36d65b5263
ROOST_METHOD_SIG_HASH=FollowUser_bf8ceb04bb

FUNCTION_DEF=func (h *Handler) FollowUser(ctx context.Context, req *pb.FollowRequest) (*pb.ProfileResponse, error)
Based on the provided function and context, here are several test scenarios for the `FollowUser` function:

```
Scenario 1: Successful User Follow

Details:
  Description: Test the successful following of one user by another.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock user service that returns valid current user and request user
    - Ensure the mock Follow method succeeds
  Act: Call FollowUser with a valid follow request
  Assert:
    - Expect a non-nil ProfileResponse
    - Expect the returned profile to have following set to true
    - Expect no error to be returned
Validation:
  This test ensures the happy path works correctly, validating that users can follow each other as expected.

Scenario 2: Attempt to Follow Self

Details:
  Description: Test the case where a user attempts to follow themselves.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns the same user for both current and request user
  Act: Call FollowUser with a request containing the current user's username
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with codes.InvalidArgument
    - Verify the error message contains "cannot follow yourself"
Validation:
  This test verifies that the function correctly prevents users from following themselves, which is a business rule.

Scenario 3: Follow Non-existent User

Details:
  Description: Test the behavior when attempting to follow a user that doesn't exist.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid current user
    - Configure the mock to return an error for GetByUsername
  Act: Call FollowUser with a non-existent username
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with codes.NotFound
    - Verify the error message contains "user was not found"
Validation:
  This test ensures proper error handling when the requested user to follow doesn't exist in the system.

Scenario 4: Unauthenticated Request

Details:
  Description: Test the function's behavior when the request is not authenticated.
Execution:
  Arrange:
    - Set up a mock context that fails authentication check
  Act: Call FollowUser with any valid request
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with codes.Unauthenticated
    - Verify the error message contains "unauthenticated"
Validation:
  This test verifies that the function correctly handles unauthenticated requests, which is crucial for security.

Scenario 5: Current User Not Found

Details:
  Description: Test the case where the authenticated user is not found in the database.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Configure the mock user service to return an error for GetByID
  Act: Call FollowUser with any valid request
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with codes.NotFound
    - Verify the error message contains "user not found"
Validation:
  This test ensures proper error handling in the unlikely event that an authenticated user's record is not found.

Scenario 6: Follow Operation Failure

Details:
  Description: Test the behavior when the follow operation fails in the user service.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock user service that returns valid current user and request user
    - Configure the mock Follow method to return an error
  Act: Call FollowUser with a valid follow request
  Assert:
    - Expect a nil ProfileResponse
    - Expect an error with codes.Aborted
    - Verify the error message contains "failed to follow user"
Validation:
  This test verifies that the function handles database or service-level errors during the follow operation correctly.
```

These test scenarios cover the main paths through the `FollowUser` function, including successful operation, various error conditions, and edge cases. They ensure that the function behaves correctly under different circumstances, properly handles errors, and adheres to the business rules (such as not allowing self-following).
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
)

// mockUserStore is a mock of the UserStore interface
type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id int64) (*model.User, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) GetByUsername(username string) (*model.User, error) {
	args := m.Called(username)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) Follow(follower, followee *model.User) error {
	args := m.Called(follower, followee)
	return args.Error(0)
}

func TestFollowUser(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*mockUserStore)
		setupAuth      func(context.Context) context.Context
		input          *pb.FollowRequest
		expectedOutput *pb.ProfileResponse
		expectedError  error
	}{
		{
			name: "Successful User Follow",
			setupMocks: func(us *mockUserStore) {
				us.On("GetByID", int64(1)).Return(&model.User{ID: 1, Username: "user1"}, nil)
				us.On("GetByUsername", "user2").Return(&model.User{ID: 2, Username: "user2"}, nil)
				us.On("Follow", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(nil)
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, int64(1))
			},
			input: &pb.FollowRequest{Username: "user2"},
			expectedOutput: &pb.ProfileResponse{
				Profile: &pb.Profile{
					Username:  "user2",
					Following: true,
				},
			},
			expectedError: nil,
		},
		{
			name: "Attempt to Follow Self",
			setupMocks: func(us *mockUserStore) {
				us.On("GetByID", int64(1)).Return(&model.User{ID: 1, Username: "user1"}, nil)
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, int64(1))
			},
			input:          &pb.FollowRequest{Username: "user1"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "cannot follow yourself"),
		},
		{
			name: "Follow Non-existent User",
			setupMocks: func(us *mockUserStore) {
				us.On("GetByID", int64(1)).Return(&model.User{ID: 1, Username: "user1"}, nil)
				us.On("GetByUsername", "nonexistent").Return(nil, errors.New("user not found"))
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, int64(1))
			},
			input:          &pb.FollowRequest{Username: "nonexistent"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.NotFound, "user was not found"),
		},
		{
			name:       "Unauthenticated Request",
			setupMocks: func(us *mockUserStore) {},
			setupAuth: func(ctx context.Context) context.Context {
				return ctx // No authentication
			},
			input:          &pb.FollowRequest{Username: "user2"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Current User Not Found",
			setupMocks: func(us *mockUserStore) {
				us.On("GetByID", int64(1)).Return(nil, errors.New("user not found"))
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, int64(1))
			},
			input:          &pb.FollowRequest{Username: "user2"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.NotFound, "user not found"),
		},
		{
			name: "Follow Operation Failure",
			setupMocks: func(us *mockUserStore) {
				us.On("GetByID", int64(1)).Return(&model.User{ID: 1, Username: "user1"}, nil)
				us.On("GetByUsername", "user2").Return(&model.User{ID: 2, Username: "user2"}, nil)
				us.On("Follow", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(errors.New("follow failed"))
			},
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, int64(1))
			},
			input:          &pb.FollowRequest{Username: "user2"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.Aborted, "failed to follow user"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockUS := new(mockUserStore)
			tt.setupMocks(mockUS)

			h := &Handler{
				logger: zerolog.Nop(),
				us:     mockUS,
			}

			ctx := tt.setupAuth(context.Background())

			// Execute
			response, err := h.FollowUser(ctx, tt.input)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
			}

			assert.Equal(t, tt.expectedOutput, response)

			// Verify all expectations were met
			mockUS.AssertExpectations(t)
		})
	}
}
