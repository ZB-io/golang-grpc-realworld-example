// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=FollowUser_36d65b5263
ROOST_METHOD_SIG_HASH=FollowUser_bf8ceb04bb

FUNCTION_DEF=func (h *Handler) FollowUser(ctx context.Context, req *pb.FollowRequest) (*pb.ProfileResponse, error)
Based on the provided function and context, here are several test scenarios for the `FollowUser` function:

```
Scenario 1: Successfully follow a user

Details:
  Description: Test that a user can successfully follow another user when all conditions are met.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with two valid users
    - Configure mock UserStore to return success on Follow method
  Act:
    - Call FollowUser with the context and a valid FollowRequest
  Assert:
    - Verify that the returned ProfileResponse contains the correct profile
    - Check that no error is returned
Validation:
  This test ensures the happy path works as expected, validating that users can follow each other when all conditions are met. It's crucial for the core functionality of the application.

Scenario 2: Attempt to follow oneself

Details:
  Description: Verify that a user cannot follow themselves.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with a single user
  Act:
    - Call FollowUser with the context and a FollowRequest containing the user's own username
  Assert:
    - Expect an error with codes.InvalidArgument
    - Verify that the error message indicates "cannot follow yourself"
Validation:
  This test checks an important business rule that prevents users from following themselves, ensuring the integrity of the follower/following relationship.

Scenario 3: Follow a non-existent user

Details:
  Description: Test the behavior when attempting to follow a user that doesn't exist.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore to return an error when GetByUsername is called
  Act:
    - Call FollowUser with the context and a FollowRequest containing a non-existent username
  Assert:
    - Expect an error with codes.NotFound
    - Verify that the error message indicates "user was not found"
Validation:
  This test ensures proper error handling when dealing with non-existent users, which is crucial for maintaining data integrity and providing clear feedback to the client.

Scenario 4: Unauthenticated follow attempt

Details:
  Description: Verify that an unauthenticated user cannot follow another user.
Execution:
  Arrange:
    - Create a mock context that fails authentication
  Act:
    - Call FollowUser with the invalid context and a valid FollowRequest
  Assert:
    - Expect an error with codes.Unauthenticated
    - Verify that the error message indicates "unauthenticated"
Validation:
  This test is crucial for ensuring that the authentication mechanism is working correctly and that only authenticated users can perform follow actions.

Scenario 5: Database error during follow operation

Details:
  Description: Test the behavior when a database error occurs during the follow operation.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore with two valid users
    - Configure mock UserStore to return an error on Follow method
  Act:
    - Call FollowUser with the context and a valid FollowRequest
  Assert:
    - Expect an error with codes.Aborted
    - Verify that the error message indicates "failed to follow user"
Validation:
  This test ensures that the function handles database errors gracefully, providing appropriate feedback without exposing internal details to the client.

Scenario 6: Current user not found

Details:
  Description: Verify behavior when the authenticated user is not found in the database.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock UserStore to return an error when GetByID is called
  Act:
    - Call FollowUser with the context and a valid FollowRequest
  Assert:
    - Expect an error with codes.NotFound
    - Verify that the error message indicates "user not found"
Validation:
  This test checks for proper error handling in case of data inconsistency between the authentication system and the database, which is important for system integrity.
```

These test scenarios cover various aspects of the `FollowUser` function, including successful operation, error handling, and edge cases. They take into account the provided package structure, imports, and struct definitions to create realistic test scenarios.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gorm.io/gorm"
)

// MockUserStore is a mock of UserStore interface
type MockUserStore struct {
	GetByIDFunc       func(uint) (*store.User, error)
	GetByUsernameFunc func(string) (*store.User, error)
	FollowFunc        func(*store.User, *store.User) error
}

func (m *MockUserStore) GetByID(id uint) (*store.User, error) {
	return m.GetByIDFunc(id)
}

func (m *MockUserStore) GetByUsername(username string) (*store.User, error) {
	return m.GetByUsernameFunc(username)
}

func (m *MockUserStore) Follow(a *store.User, b *store.User) error {
	return m.FollowFunc(a, b)
}

func TestHandlerFollowUser(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*MockUserStore)
		ctx            context.Context
		req            *proto.FollowRequest
		expectedResp   *proto.ProfileResponse
		expectedErrMsg string
		expectedCode   codes.Code
	}{
		{
			name: "Successfully follow a user",
			setupMocks: func(mockUS *MockUserStore) {
				mockUS.GetByIDFunc = func(id uint) (*store.User, error) {
					return &store.User{ID: 1, Username: "user1"}, nil
				}
				mockUS.GetByUsernameFunc = func(username string) (*store.User, error) {
					return &store.User{ID: 2, Username: "user2"}, nil
				}
				mockUS.FollowFunc = func(a *store.User, b *store.User) error {
					return nil
				}
			},
			ctx: auth.NewContextWithUserID(context.Background(), 1),
			req: &proto.FollowRequest{Username: "user2"},
			expectedResp: &proto.ProfileResponse{
				Profile: &proto.Profile{
					Username:  "user2",
					Following: true,
				},
			},
		},
		{
			name: "Attempt to follow oneself",
			setupMocks: func(mockUS *MockUserStore) {
				mockUS.GetByIDFunc = func(id uint) (*store.User, error) {
					return &store.User{ID: 1, Username: "user1"}, nil
				}
			},
			ctx:            auth.NewContextWithUserID(context.Background(), 1),
			req:            &proto.FollowRequest{Username: "user1"},
			expectedErrMsg: "cannot follow yourself",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Follow a non-existent user",
			setupMocks: func(mockUS *MockUserStore) {
				mockUS.GetByIDFunc = func(id uint) (*store.User, error) {
					return &store.User{ID: 1, Username: "user1"}, nil
				}
				mockUS.GetByUsernameFunc = func(username string) (*store.User, error) {
					return nil, gorm.ErrRecordNotFound
				}
			},
			ctx:            auth.NewContextWithUserID(context.Background(), 1),
			req:            &proto.FollowRequest{Username: "nonexistent"},
			expectedErrMsg: "user was not found",
			expectedCode:   codes.NotFound,
		},
		{
			name:           "Unauthenticated follow attempt",
			setupMocks:     func(mockUS *MockUserStore) {},
			ctx:            context.Background(),
			req:            &proto.FollowRequest{Username: "user2"},
			expectedErrMsg: "unauthenticated",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Database error during follow operation",
			setupMocks: func(mockUS *MockUserStore) {
				mockUS.GetByIDFunc = func(id uint) (*store.User, error) {
					return &store.User{ID: 1, Username: "user1"}, nil
				}
				mockUS.GetByUsernameFunc = func(username string) (*store.User, error) {
					return &store.User{ID: 2, Username: "user2"}, nil
				}
				mockUS.FollowFunc = func(a *store.User, b *store.User) error {
					return errors.New("database error")
				}
			},
			ctx:            auth.NewContextWithUserID(context.Background(), 1),
			req:            &proto.FollowRequest{Username: "user2"},
			expectedErrMsg: "failed to follow user",
			expectedCode:   codes.Aborted,
		},
		{
			name: "Current user not found",
			setupMocks: func(mockUS *MockUserStore) {
				mockUS.GetByIDFunc = func(id uint) (*store.User, error) {
					return nil, gorm.ErrRecordNotFound
				}
			},
			ctx:            auth.NewContextWithUserID(context.Background(), 1),
			req:            &proto.FollowRequest{Username: "user2"},
			expectedErrMsg: "user not found",
			expectedCode:   codes.NotFound,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUS := &MockUserStore{}
			tt.setupMocks(mockUS)

			h := &Handler{
				logger: zerolog.Nop(),
				us:     mockUS,
			}

			resp, err := h.FollowUser(tt.ctx, tt.req)

			if tt.expectedErrMsg != "" {
				if err == nil {
					t.Errorf("expected error, got nil")
					return
				}
				st, ok := status.FromError(err)
				if !ok {
					t.Errorf("expected gRPC status error, got %v", err)
					return
				}
				if st.Code() != tt.expectedCode {
					t.Errorf("expected error code %v, got %v", tt.expectedCode, st.Code())
				}
				if st.Message() != tt.expectedErrMsg {
					t.Errorf("expected error message %q, got %q", tt.expectedErrMsg, st.Message())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
					return
				}
				if resp == nil {
					t.Error("expected non-nil response, got nil")
					return
				}
				if resp.Profile.Username != tt.expectedResp.Profile.Username {
					t.Errorf("expected username %q, got %q", tt.expectedResp.Profile.Username, resp.Profile.Username)
				}
				if resp.Profile.Following != tt.expectedResp.Profile.Following {
					t.Errorf("expected following %v, got %v", tt.expectedResp.Profile.Following, resp.Profile.Following)
				}
			}
		})
	}
}
