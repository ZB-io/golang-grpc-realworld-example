// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=ShowProfile_3cf6e3a9fd
ROOST_METHOD_SIG_HASH=ShowProfile_4679c3d9a4

FUNCTION_DEF=func (h *Handler) ShowProfile(ctx context.Context, req *pb.ShowProfileRequest) (*pb.ProfileResponse, error)
Based on the provided function and context, here are several test scenarios for the `ShowProfile` function:

```
Scenario 1: Successful Profile Retrieval

Details:
  Description: Test the successful retrieval of a user's profile when all conditions are met.
Execution:
  Arrange:
    - Set up a mock UserStore with a current user and a request user
    - Configure the mock to return valid users for GetByID and GetByUsername
    - Set up a mock context that returns a valid userID
    - Configure IsFollowing to return a known value (e.g., true)
  Act:
    - Call ShowProfile with the arranged context and a valid ShowProfileRequest
  Assert:
    - Verify that the returned ProfileResponse is not nil
    - Check that the Profile in the response matches the expected user data
    - Ensure the following status in the profile matches the mocked IsFollowing result
Validation:
  This test ensures the happy path works correctly, validating that when all preconditions are met, the function returns the correct user profile with accurate following status.

Scenario 2: Unauthenticated Request

Details:
  Description: Test the behavior when the request is not authenticated.
Execution:
  Arrange:
    - Set up a mock context that fails to return a valid userID (simulating auth.GetUserID failure)
  Act:
    - Call ShowProfile with the unauthenticated context and a valid ShowProfileRequest
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with Unauthenticated code
Validation:
  This test verifies that the function correctly handles and reports unauthenticated requests, which is crucial for maintaining security in the application.

Scenario 3: Current User Not Found

Details:
  Description: Test the scenario where the authenticated user is not found in the database.
Execution:
  Arrange:
    - Set up a mock context that returns a valid userID
    - Configure the UserStore mock to return an error for GetByID
  Act:
    - Call ShowProfile with the arranged context and a valid ShowProfileRequest
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with NotFound code
Validation:
  This test ensures that the function handles database inconsistencies gracefully, returning an appropriate error when the current user can't be found.

Scenario 4: Requested User Not Found

Details:
  Description: Test the behavior when the requested user profile does not exist.
Execution:
  Arrange:
    - Set up a mock context that returns a valid userID
    - Configure the UserStore mock to return a valid user for GetByID (current user)
    - Configure GetByUsername to return an error (simulating non-existent user)
  Act:
    - Call ShowProfile with the arranged context and a ShowProfileRequest for a non-existent user
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with NotFound code
Validation:
  This test verifies that the function correctly handles and reports attempts to view non-existent user profiles, which is important for user experience and data integrity.

Scenario 5: Error Checking Following Status

Details:
  Description: Test the scenario where there's an error determining the following status.
Execution:
  Arrange:
    - Set up a mock context that returns a valid userID
    - Configure the UserStore mock to return valid users for both GetByID and GetByUsername
    - Configure IsFollowing to return an error
  Act:
    - Call ShowProfile with the arranged context and a valid ShowProfileRequest
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with Internal code
Validation:
  This test ensures that the function handles internal errors gracefully, particularly when determining the following status fails. It's crucial for maintaining system reliability and providing appropriate feedback.

Scenario 6: Successful Profile Retrieval with Non-Following Status

Details:
  Description: Test successful profile retrieval when the current user is not following the requested user.
Execution:
  Arrange:
    - Set up similar to Scenario 1, but configure IsFollowing to return false
  Act:
    - Call ShowProfile with the arranged context and a valid ShowProfileRequest
  Assert:
    - Verify that the returned ProfileResponse is not nil
    - Check that the Profile in the response matches the expected user data
    - Ensure the following status in the profile is false
Validation:
  This test complements Scenario 1 by verifying the correct behavior when the users have a different relationship. It ensures that the following status is accurately reflected in various user interactions.
```

These scenarios cover the main paths through the `ShowProfile` function, including successful operations and various error conditions. They test authentication, database operations, and the correct handling of the following status, which are key aspects of the function's behavior.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
)

func TestHandlerShowProfile(t *testing.T) {
	tests := []struct {
		name            string
		setupMock       func(*mockUserStore)
		userID          uint
		requestUser     string
		expectedProfile *pb.Profile
		expectedError   error
	}{
		{
			name: "Successful Profile Retrieval",
			setupMock: func(m *mockUserStore) {
				m.On("GetByID", uint(1)).Return(&model.User{ID: 1, Username: "currentUser"}, nil)
				m.On("GetByUsername", "requestUser").Return(&model.User{ID: 2, Username: "requestUser"}, nil)
				m.On("IsFollowing", mock.Anything, mock.Anything).Return(true, nil)
			},
			userID:      1,
			requestUser: "requestUser",
			expectedProfile: &pb.Profile{
				Username:  "requestUser",
				Following: true,
			},
			expectedError: nil,
		},
		{
			name:            "Unauthenticated Request",
			setupMock:       func(m *mockUserStore) {},
			userID:          0,
			requestUser:     "requestUser",
			expectedProfile: nil,
			expectedError:   status.Errorf(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Current User Not Found",
			setupMock: func(m *mockUserStore) {
				m.On("GetByID", uint(1)).Return(nil, fmt.Errorf("user not found"))
			},
			userID:          1,
			requestUser:     "requestUser",
			expectedProfile: nil,
			expectedError:   status.Error(codes.NotFound, "user not found"),
		},
		{
			name: "Requested User Not Found",
			setupMock: func(m *mockUserStore) {
				m.On("GetByID", uint(1)).Return(&model.User{ID: 1, Username: "currentUser"}, nil)
				m.On("GetByUsername", "nonExistentUser").Return(nil, fmt.Errorf("user not found"))
			},
			userID:          1,
			requestUser:     "nonExistentUser",
			expectedProfile: nil,
			expectedError:   status.Error(codes.NotFound, "user was not found"),
		},
		{
			name: "Error Checking Following Status",
			setupMock: func(m *mockUserStore) {
				m.On("GetByID", uint(1)).Return(&model.User{ID: 1, Username: "currentUser"}, nil)
				m.On("GetByUsername", "requestUser").Return(&model.User{ID: 2, Username: "requestUser"}, nil)
				m.On("IsFollowing", mock.Anything, mock.Anything).Return(false, fmt.Errorf("database error"))
			},
			userID:          1,
			requestUser:     "requestUser",
			expectedProfile: nil,
			expectedError:   status.Error(codes.Internal, "internal server error"),
		},
		{
			name: "Successful Profile Retrieval with Non-Following Status",
			setupMock: func(m *mockUserStore) {
				m.On("GetByID", uint(1)).Return(&model.User{ID: 1, Username: "currentUser"}, nil)
				m.On("GetByUsername", "requestUser").Return(&model.User{ID: 2, Username: "requestUser"}, nil)
				m.On("IsFollowing", mock.Anything, mock.Anything).Return(false, nil)
			},
			userID:      1,
			requestUser: "requestUser",
			expectedProfile: &pb.Profile{
				Username:  "requestUser",
				Following: false,
			},
			expectedError: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUS := new(mockUserStore)
			tt.setupMock(mockUS)

			h := &Handler{
				us: mockUS,
				// TODO: Add mock logger if needed
			}

			ctx := context.WithValue(context.Background(), "user_id", tt.userID)
			req := &pb.ShowProfileRequest{Username: tt.requestUser}

			resp, err := h.ShowProfile(ctx, req)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, resp)
				assert.Equal(t, tt.expectedProfile, resp.Profile)
			}

			mockUS.AssertExpectations(t)
		})
	}
}

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) GetByUsername(username string) (*model.User, error) {
	args := m.Called(username)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}
