// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=ShowProfile_3cf6e3a9fd
ROOST_METHOD_SIG_HASH=ShowProfile_4679c3d9a4

FUNCTION_DEF=func (h *Handler) ShowProfile(ctx context.Context, req *pb.ShowProfileRequest) (*pb.ProfileResponse, error)
Based on the provided function and context, here are several test scenarios for the `ShowProfile` function:

```
Scenario 1: Successfully retrieve a user's profile

Details:
  Description: This test verifies that the function can successfully retrieve and return a user's profile when all conditions are met.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock user service (us) that returns valid current user and request user
    - Set up the mock user service to return a "following" status
  Act:
    - Call ShowProfile with a valid username in the request
  Assert:
    - Verify that the returned ProfileResponse is not nil
    - Check that the returned profile matches the expected user data
    - Ensure the "following" status in the profile is correct
Validation:
  This test is crucial as it verifies the primary happy path of the function. It ensures that authenticated users can view profiles correctly, which is a core feature of the application.

Scenario 2: Attempt to view a profile with unauthenticated user

Details:
  Description: This test checks if the function correctly handles and returns an error when the user is not authenticated.
Execution:
  Arrange:
    - Set up a mock context that fails authentication
    - Configure auth.GetUserID to return an error
  Act:
    - Call ShowProfile with any username in the request
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with Unauthenticated code
Validation:
  This test is important for security, ensuring that unauthenticated users cannot access profile information.

Scenario 3: Attempt to view a non-existent user's profile

Details:
  Description: This test verifies that the function handles the case where the requested username does not exist in the system.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid current user
    - Configure the user service to return an error when GetByUsername is called
  Act:
    - Call ShowProfile with a non-existent username in the request
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with NotFound code
Validation:
  This test ensures proper error handling when users attempt to view profiles that don't exist, preventing confusion and potential security issues.

Scenario 4: Internal server error when checking following status

Details:
  Description: This test checks the function's behavior when there's an internal error while determining the following status.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock user service that returns valid current user and request user
    - Configure the IsFollowing method to return an error
  Act:
    - Call ShowProfile with a valid username in the request
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with Internal code
Validation:
  This test is important for verifying proper error handling in case of internal server issues, ensuring that the client receives appropriate feedback.

Scenario 5: Current user not found

Details:
  Description: This test verifies the function's behavior when the authenticated user's information cannot be retrieved.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Configure the user service to return an error when GetByID is called
  Act:
    - Call ShowProfile with any username in the request
  Assert:
    - Verify that the function returns a nil ProfileResponse
    - Check that the returned error is a gRPC error with NotFound code
Validation:
  This test ensures proper error handling in case of data inconsistencies where an authenticated user's data is not found in the database.
```

These scenarios cover the main happy path, authentication issues, data retrieval problems, and internal server errors. They provide a comprehensive test suite for the `ShowProfile` function, ensuring it behaves correctly under various conditions.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestShowProfile(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*Handler)
		input          *pb.ShowProfileRequest
		expectedOutput *pb.ProfileResponse
		expectedError  error
	}{
		{
			name: "Successfully retrieve a user's profile",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.(*store.UserStoreMock).GetByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{ID: 1, Username: "current_user"}, nil
				}
				h.us.(*store.UserStoreMock).GetByUsernameFunc = func(username string) (*model.User, error) {
					return &model.User{ID: 2, Username: "request_user"}, nil
				}
				h.us.(*store.UserStoreMock).IsFollowingFunc = func(follower, followee *model.User) (bool, error) {
					return true, nil
				}
			},
			input: &pb.ShowProfileRequest{Username: "request_user"},
			expectedOutput: &pb.ProfileResponse{
				Profile: &pb.Profile{
					Username:  "request_user",
					Following: true,
				},
			},
			expectedError: nil,
		},
		{
			name: "Attempt to view a profile with unauthenticated user",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 0, errors.New("unauthenticated")
				}
			},
			input:          &pb.ShowProfileRequest{Username: "any_user"},
			expectedOutput: nil,
			expectedError:  status.Errorf(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "Attempt to view a non-existent user's profile",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.(*store.UserStoreMock).GetByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{ID: 1, Username: "current_user"}, nil
				}
				h.us.(*store.UserStoreMock).GetByUsernameFunc = func(username string) (*model.User, error) {
					return nil, errors.New("user not found")
				}
			},
			input:          &pb.ShowProfileRequest{Username: "non_existent_user"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.NotFound, "user was not found"),
		},
		{
			name: "Internal server error when checking following status",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.(*store.UserStoreMock).GetByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{ID: 1, Username: "current_user"}, nil
				}
				h.us.(*store.UserStoreMock).GetByUsernameFunc = func(username string) (*model.User, error) {
					return &model.User{ID: 2, Username: "request_user"}, nil
				}
				h.us.(*store.UserStoreMock).IsFollowingFunc = func(follower, followee *model.User) (bool, error) {
					return false, errors.New("internal server error")
				}
			},
			input:          &pb.ShowProfileRequest{Username: "request_user"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.Internal, "failed to get following status"),
		},
		{
			name: "Current user not found",
			setupMocks: func(h *Handler) {
				auth.GetUserID = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				h.us.(*store.UserStoreMock).GetByIDFunc = func(id uint) (*model.User, error) {
					return nil, errors.New("user not found")
				}
			},
			input:          &pb.ShowProfileRequest{Username: "any_user"},
			expectedOutput: nil,
			expectedError:  status.Error(codes.NotFound, "user not found"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a new Handler with mocked dependencies
			h := &Handler{
				logger: zerolog.Nop(),
				us:     &store.UserStoreMock{},
				as:     &store.ArticleStoreMock{},
			}

			// Setup mocks
			tt.setupMocks(h)

			// Call the function
			got, err := h.ShowProfile(context.Background(), tt.input)

			// Check the error
			if (err != nil) != (tt.expectedError != nil) {
				t.Errorf("ShowProfile() error = %v, expectedError %v", err, tt.expectedError)
				return
			}
			if err != nil && err.Error() != tt.expectedError.Error() {
				t.Errorf("ShowProfile() error = %v, expectedError %v", err, tt.expectedError)
				return
			}

			// Check the output
			if (got != nil) != (tt.expectedOutput != nil) {
				t.Errorf("ShowProfile() got = %v, expected %v", got, tt.expectedOutput)
				return
			}
			if got != nil && tt.expectedOutput != nil {
				if got.Profile.Username != tt.expectedOutput.Profile.Username {
					t.Errorf("ShowProfile() got username = %v, expected username %v", got.Profile.Username, tt.expectedOutput.Profile.Username)
				}
				if got.Profile.Following != tt.expectedOutput.Profile.Following {
					t.Errorf("ShowProfile() got following = %v, expected following %v", got.Profile.Following, tt.expectedOutput.Profile.Following)
				}
			}
		})
	}
}
