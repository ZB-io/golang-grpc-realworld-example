// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=ShowProfile_3cf6e3a9fd
ROOST_METHOD_SIG_HASH=ShowProfile_4679c3d9a4

FUNCTION_DEF=func (h *Handler) ShowProfile(ctx context.Context, req *pb.ShowProfileRequest) (*pb.ProfileResponse, error)
Here are several test scenarios for the ShowProfile function:

```
Scenario 1: Successfully Retrieve Profile for Existing User

Details:
  Description: This test verifies that the ShowProfile function correctly retrieves and returns the profile of an existing user when called by an authenticated user.

Execution:
  Arrange:
    - Mock the auth.GetUserID function to return a valid user ID
    - Set up a mock UserStore with GetByID and GetByUsername methods that return valid user objects
    - Set up the mock UserStore's IsFollowing method to return a known following status
    - Create a mock pb.ShowProfileRequest with a valid username
  Act:
    - Call the ShowProfile function with the prepared context and request
  Assert:
    - Verify that the returned pb.ProfileResponse is not nil
    - Check that the Profile field in the response matches the expected user profile
    - Ensure the following status in the profile matches the mock IsFollowing result

Validation:
  This test is crucial as it validates the primary happy path of the ShowProfile function. It ensures that when all conditions are met (authenticated user, existing target user), the function correctly retrieves and formats the user profile information.

Scenario 2: Attempt to Retrieve Profile When Unauthenticated

Details:
  Description: This test checks that the ShowProfile function returns an Unauthenticated error when the user is not authenticated.

Execution:
  Arrange:
    - Mock the auth.GetUserID function to return an error
    - Create a mock pb.ShowProfileRequest with any username
  Act:
    - Call the ShowProfile function with the prepared context and request
  Assert:
    - Verify that the returned error is not nil
    - Check that the error status code is codes.Unauthenticated

Validation:
  This test is important for ensuring the security of the application. It verifies that unauthenticated users cannot access profile information, maintaining user privacy and system integrity.

Scenario 3: Attempt to Retrieve Profile for Non-existent User

Details:
  Description: This test verifies that the ShowProfile function returns a NotFound error when the requested username does not exist in the system.

Execution:
  Arrange:
    - Mock the auth.GetUserID function to return a valid user ID
    - Set up a mock UserStore with GetByID that returns a valid current user
    - Set up the mock UserStore's GetByUsername method to return an error (simulating user not found)
    - Create a mock pb.ShowProfileRequest with a non-existent username
  Act:
    - Call the ShowProfile function with the prepared context and request
  Assert:
    - Verify that the returned error is not nil
    - Check that the error status code is codes.NotFound

Validation:
  This test ensures that the function handles the case of requesting a non-existent user profile gracefully. It's important for providing clear feedback to the client and maintaining system robustness.

Scenario 4: Handle Error When Checking Following Status

Details:
  Description: This test checks that the ShowProfile function returns an Internal Server Error when there's an issue determining the following status.

Execution:
  Arrange:
    - Mock the auth.GetUserID function to return a valid user ID
    - Set up a mock UserStore with GetByID and GetByUsername methods that return valid user objects
    - Set up the mock UserStore's IsFollowing method to return an error
    - Create a mock pb.ShowProfileRequest with a valid username
  Act:
    - Call the ShowProfile function with the prepared context and request
  Assert:
    - Verify that the returned error is not nil
    - Check that the error status code is codes.Internal

Validation:
  This test is crucial for error handling and system reliability. It ensures that when an unexpected error occurs during the following status check, the function fails gracefully and returns an appropriate error to the client.

Scenario 5: Current User Not Found

Details:
  Description: This test verifies that the ShowProfile function returns a NotFound error when the current user (based on the authentication) is not found in the system.

Execution:
  Arrange:
    - Mock the auth.GetUserID function to return a valid user ID
    - Set up a mock UserStore with GetByID method that returns an error (simulating current user not found)
    - Create a mock pb.ShowProfileRequest with any username
  Act:
    - Call the ShowProfile function with the prepared context and request
  Assert:
    - Verify that the returned error is not nil
    - Check that the error status code is codes.NotFound

Validation:
  This test is important for handling edge cases where the authenticated user ID doesn't correspond to an existing user. It ensures the system behaves correctly in unexpected scenarios, contributing to overall robustness.
```

These test scenarios cover the main functionality of the ShowProfile function, including successful operation, authentication checks, error handling for non-existent users, and internal error conditions. They provide a comprehensive test suite for validating the function's behavior under various circumstances.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestHandlerShowProfile(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*HandlerMock)
		req            *pb.ShowProfileRequest
		expectedResp   *pb.ProfileResponse
		expectedErrMsg string
		expectedCode   codes.Code
	}{
		{
			name: "Successfully Retrieve Profile for Existing User",
			setupMocks: func(m *HandlerMock) {
				m.AuthGetUserIDFunc = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				m.UserStoreGetByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{ID: 1}, nil
				}
				m.UserStoreGetByUsernameFunc = func(username string) (*model.User, error) {
					return &model.User{ID: 2, Username: "testuser"}, nil
				}
				m.UserStoreIsFollowingFunc = func(follower, followed *model.User) (bool, error) {
					return true, nil
				}
			},
			req: &pb.ShowProfileRequest{Username: "testuser"},
			expectedResp: &pb.ProfileResponse{
				Profile: &pb.Profile{
					Username:  "testuser",
					Following: true,
				},
			},
		},
		{
			name: "Attempt to Retrieve Profile When Unauthenticated",
			setupMocks: func(m *HandlerMock) {
				m.AuthGetUserIDFunc = func(ctx context.Context) (uint, error) {
					return 0, errors.New("unauthenticated")
				}
			},
			req:            &pb.ShowProfileRequest{Username: "testuser"},
			expectedErrMsg: "unauthenticated",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Attempt to Retrieve Profile for Non-existent User",
			setupMocks: func(m *HandlerMock) {
				m.AuthGetUserIDFunc = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				m.UserStoreGetByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{ID: 1}, nil
				}
				m.UserStoreGetByUsernameFunc = func(username string) (*model.User, error) {
					return nil, errors.New("user not found")
				}
			},
			req:            &pb.ShowProfileRequest{Username: "nonexistent"},
			expectedErrMsg: "user was not found",
			expectedCode:   codes.NotFound,
		},
		{
			name: "Handle Error When Checking Following Status",
			setupMocks: func(m *HandlerMock) {
				m.AuthGetUserIDFunc = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				m.UserStoreGetByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{ID: 1}, nil
				}
				m.UserStoreGetByUsernameFunc = func(username string) (*model.User, error) {
					return &model.User{ID: 2, Username: "testuser"}, nil
				}
				m.UserStoreIsFollowingFunc = func(follower, followed *model.User) (bool, error) {
					return false, errors.New("database error")
				}
			},
			req:            &pb.ShowProfileRequest{Username: "testuser"},
			expectedErrMsg: "internal server error",
			expectedCode:   codes.Internal,
		},
		{
			name: "Current User Not Found",
			setupMocks: func(m *HandlerMock) {
				m.AuthGetUserIDFunc = func(ctx context.Context) (uint, error) {
					return 1, nil
				}
				m.UserStoreGetByIDFunc = func(id uint) (*model.User, error) {
					return nil, errors.New("user not found")
				}
			},
			req:            &pb.ShowProfileRequest{Username: "testuser"},
			expectedErrMsg: "user not found",
			expectedCode:   codes.NotFound,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &HandlerMock{
				Logger: zerolog.New(nil),
			}
			tt.setupMocks(m)

			h := &Handler{
				logger: &m.Logger,
				us:     m,
				as:     &store.ArticleStore{},
			}

			resp, err := h.ShowProfile(context.Background(), tt.req)

			if tt.expectedErrMsg != "" {
				if err == nil {
					t.Fatalf("expected error, got nil")
				}
				st, ok := status.FromError(err)
				if !ok {
					t.Fatalf("expected gRPC status error, got %v", err)
				}
				if st.Code() != tt.expectedCode {
					t.Errorf("expected error code %v, got %v", tt.expectedCode, st.Code())
				}
				if st.Message() != tt.expectedErrMsg {
					t.Errorf("expected error message %q, got %q", tt.expectedErrMsg, st.Message())
				}
			} else {
				if err != nil {
					t.Fatalf("unexpected error: %v", err)
				}
				if resp == nil {
					t.Fatalf("expected non-nil response, got nil")
				}
				if resp.Profile.Username != tt.expectedResp.Profile.Username {
					t.Errorf("expected username %q, got %q", tt.expectedResp.Profile.Username, resp.Profile.Username)
				}
				if resp.Profile.Following != tt.expectedResp.Profile.Following {
					t.Errorf("expected following status %v, got %v", tt.expectedResp.Profile.Following, resp.Profile.Following)
				}
			}
		})
	}
}

type HandlerMock struct {
	Handler
	Logger                     zerolog.Logger
	AuthGetUserIDFunc          func(ctx context.Context) (uint, error)
	UserStoreGetByIDFunc       func(id uint) (*model.User, error)
	UserStoreGetByUsernameFunc func(username string) (*model.User, error)
	UserStoreIsFollowingFunc   func(follower, followed *model.User) (bool, error)
}

func (m *HandlerMock) GetUserID(ctx context.Context) (uint, error) {
	return m.AuthGetUserIDFunc(ctx)
}

func (m *HandlerMock) GetByID(id uint) (*model.User, error) {
	return m.UserStoreGetByIDFunc(id)
}

func (m *HandlerMock) GetByUsername(username string) (*model.User, error) {
	return m.UserStoreGetByUsernameFunc(username)
}

func (m *HandlerMock) IsFollowing(follower, followed *model.User) (bool, error) {
	return m.UserStoreIsFollowingFunc(follower, followed)
}
