// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=GetComments_265127fb6a
ROOST_METHOD_SIG_HASH=GetComments_20efd5abae

FUNCTION_DEF=func (h *Handler) GetComments(ctx context.Context, req *pb.GetCommentsRequest) (*pb.CommentsResponse, error)
Based on the provided function and context, here are several test scenarios for the `GetComments` function:

```
Scenario 1: Successfully retrieve comments for a valid article

Details:
  Description: This test verifies that the function can successfully retrieve comments for a valid article when provided with a correct slug (article ID).
Execution:
  Arrange:
    - Set up a mock ArticleStore with a predefined article and its comments
    - Set up a mock UserStore with a current user and following relationships
    - Create a context with a valid user ID
    - Prepare a valid GetCommentsRequest with a slug (article ID)
  Act:
    - Call GetComments with the prepared context and request
  Assert:
    - Verify that the returned CommentsResponse is not nil
    - Check that the number of comments in the response matches the expected count
    - Validate that each comment's details (ID, body, author) are correct
    - Ensure the following status for each comment's author is accurate
Validation:
  This test is crucial as it verifies the core functionality of retrieving comments. It ensures that the function correctly interacts with the ArticleStore and UserStore, processes the data, and returns a properly formatted response.

Scenario 2: Attempt to retrieve comments with an invalid slug

Details:
  Description: This test checks the function's error handling when provided with an invalid slug that cannot be converted to an integer.
Execution:
  Arrange:
    - Prepare a GetCommentsRequest with an invalid slug (e.g., "not-a-number")
  Act:
    - Call GetComments with a valid context and the prepared request
  Assert:
    - Verify that the function returns an error
    - Check that the error is a gRPC error with the InvalidArgument code
    - Ensure the error message indicates an invalid article ID
Validation:
  This test is important for verifying the function's input validation and error handling. It ensures that the function fails gracefully and provides appropriate error information when given invalid input.

Scenario 3: Attempt to retrieve comments for a non-existent article

Details:
  Description: This test verifies the function's behavior when trying to retrieve comments for an article that doesn't exist in the database.
Execution:
  Arrange:
    - Set up a mock ArticleStore that returns an error when GetByID is called
    - Prepare a GetCommentsRequest with a valid but non-existent article ID
  Act:
    - Call GetComments with a valid context and the prepared request
  Assert:
    - Verify that the function returns an error
    - Check that the error is a gRPC error with the InvalidArgument code
    - Ensure the error message indicates an invalid article ID
Validation:
  This test is crucial for ensuring that the function handles database lookup failures correctly and provides appropriate error information to the client.

Scenario 4: Retrieve comments with no authenticated user

Details:
  Description: This test checks the function's behavior when retrieving comments without an authenticated user in the context.
Execution:
  Arrange:
    - Set up a mock ArticleStore with a predefined article and its comments
    - Prepare a GetCommentsRequest with a valid slug
    - Use a context without user authentication information
  Act:
    - Call GetComments with the prepared context and request
  Assert:
    - Verify that the function returns a valid CommentsResponse
    - Check that the comments are retrieved correctly
    - Ensure that the 'following' status for comment authors is false
Validation:
  This test is important for verifying that the function can operate correctly without user authentication, which is a valid use case for public article comments.

Scenario 5: Handle error when fetching comments from ArticleStore

Details:
  Description: This test verifies the function's error handling when the ArticleStore fails to retrieve comments.
Execution:
  Arrange:
    - Set up a mock ArticleStore that returns an error when GetComments is called
    - Prepare a valid GetCommentsRequest
  Act:
    - Call GetComments with a valid context and the prepared request
  Assert:
    - Verify that the function returns an error
    - Check that the error is a gRPC error with the Aborted code
    - Ensure the error message indicates a failure to get comments
Validation:
  This test is crucial for ensuring that the function handles database errors correctly and provides appropriate error information to the client.

Scenario 6: Handle error when checking following status

Details:
  Description: This test verifies the function's error handling when the UserStore fails to check the following status.
Execution:
  Arrange:
    - Set up mock ArticleStore and UserStore
    - Configure UserStore to return an error when IsFollowing is called
    - Prepare a valid GetCommentsRequest and context with user authentication
  Act:
    - Call GetComments with the prepared context and request
  Assert:
    - Verify that the function returns an error
    - Check that the error is a gRPC error with the NotFound code
    - Ensure the error message indicates an internal server error
Validation:
  This test is important for verifying that the function handles errors from the UserStore correctly, especially when determining the following status for comment authors.
```

These test scenarios cover various aspects of the `GetComments` function, including successful operation, input validation, error handling, and different user authentication states. They aim to ensure the function behaves correctly under normal conditions and gracefully handles various edge cases and error situations.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) GetComments(article *model.Article) ([]model.Comment, error) {
	args := m.Called(article)
	return args.Get(0).([]model.Comment), args.Error(1)
}

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}

func TestHandlerGetComments(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*mockArticleStore, *mockUserStore)
		req            *pb.GetCommentsRequest
		ctx            context.Context
		expectedResp   *pb.CommentsResponse
		expectedErrMsg string
		expectedCode   codes.Code
	}{
		{
			name: "Successfully retrieve comments for a valid article",
			setupMocks: func(as *mockArticleStore, us *mockUserStore) {
				article := &model.Article{Model: model.Model{ID: 1}}
				as.On("GetByID", uint(1)).Return(article, nil)
				comments := []model.Comment{
					{Model: model.Model{ID: 1}, Body: "Comment 1", Author: model.User{Model: model.Model{ID: 1}, Username: "user1"}},
					{Model: model.Model{ID: 2}, Body: "Comment 2", Author: model.User{Model: model.Model{ID: 2}, Username: "user2"}},
				}
				as.On("GetComments", article).Return(comments, nil)
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}}, nil)
				us.On("IsFollowing", mock.Anything, mock.Anything).Return(false, nil)
			},
			req: &pb.GetCommentsRequest{Slug: "1"},
			ctx: auth.NewContext(context.Background(), 1),
			expectedResp: &pb.CommentsResponse{
				Comments: []*pb.Comment{
					{Id: "1", Body: "Comment 1", Author: &pb.Profile{Username: "user1"}},
					{Id: "2", Body: "Comment 2", Author: &pb.Profile{Username: "user2"}},
				},
			},
		},
		{
			name:           "Attempt to retrieve comments with an invalid slug",
			req:            &pb.GetCommentsRequest{Slug: "invalid"},
			ctx:            context.Background(),
			expectedErrMsg: "invalid article id",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Attempt to retrieve comments for a non-existent article",
			setupMocks: func(as *mockArticleStore, us *mockUserStore) {
				as.On("GetByID", uint(999)).Return((*model.Article)(nil), errors.New("article not found"))
			},
			req:            &pb.GetCommentsRequest{Slug: "999"},
			ctx:            context.Background(),
			expectedErrMsg: "invalid article id",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Handle error when fetching comments from ArticleStore",
			setupMocks: func(as *mockArticleStore, us *mockUserStore) {
				article := &model.Article{Model: model.Model{ID: 1}}
				as.On("GetByID", uint(1)).Return(article, nil)
				as.On("GetComments", article).Return([]model.Comment{}, errors.New("database error"))
			},
			req:            &pb.GetCommentsRequest{Slug: "1"},
			ctx:            context.Background(),
			expectedErrMsg: "failed to get comments",
			expectedCode:   codes.Aborted,
		},
		{
			name: "Handle error when checking following status",
			setupMocks: func(as *mockArticleStore, us *mockUserStore) {
				article := &model.Article{Model: model.Model{ID: 1}}
				as.On("GetByID", uint(1)).Return(article, nil)
				comments := []model.Comment{
					{Model: model.Model{ID: 1}, Body: "Comment 1", Author: model.User{Model: model.Model{ID: 1}, Username: "user1"}},
				}
				as.On("GetComments", article).Return(comments, nil)
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}}, nil)
				us.On("IsFollowing", mock.Anything, mock.Anything).Return(false, errors.New("database error"))
			},
			req:            &pb.GetCommentsRequest{Slug: "1"},
			ctx:            auth.NewContext(context.Background(), 1),
			expectedErrMsg: "internal server error",
			expectedCode:   codes.NotFound,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockAS := new(mockArticleStore)
			mockUS := new(mockUserStore)

			if tt.setupMocks != nil {
				tt.setupMocks(mockAS, mockUS)
			}

			h := &Handler{
				logger: zerolog.New(zerolog.NewTestWriter(t)),
				as:     &store.ArticleStore{DB: mockAS},
				us:     &store.UserStore{DB: mockUS},
			}

			resp, err := h.GetComments(tt.ctx, tt.req)

			if tt.expectedErrMsg != "" {
				assert.Error(t, err)
				st, ok := status.FromError(err)
				assert.True(t, ok)
				assert.Equal(t, tt.expectedCode, st.Code())
				assert.Contains(t, st.Message(), tt.expectedErrMsg)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedResp, resp)
			}

			mockAS.AssertExpectations(t)
			mockUS.AssertExpectations(t)
		})
	}
}
