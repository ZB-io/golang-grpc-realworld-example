// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Azure Open AI and AI Model gpt-4o-standard

ROOST_METHOD_HASH=UpdateArticle_c5b82e271b
ROOST_METHOD_SIG_HASH=UpdateArticle_f36cc09d87

### Scenario 1: Valid User Updates Article Successfully

**Details:**
- **Description:** This test checks if a valid, authenticated user can successfully update an article for which they are the author. The test verifies that the function completes without errors and returns a correctly structured `ArticleResponse`.

**Execution:**
- **Arrange:** 
  - Mock the `auth.GetUserID` function to return a valid user ID.
  - Set up a `UserStore` with a user entry corresponding to the returned user ID.
  - Prepare an `ArticleStore` with an article that matches the `slug` from the request and is authored by the user with the given ID.
- **Act:** 
  - Call `UpdateArticle` with a valid context and `UpdateArticleRequest` containing correct article details.
- **Assert:** 
  - Use assertions to verify that the response contains the updated article.
  - Ensure that there are no errors returned.

**Validation:**
- **Assertion choice:** Verify that the article returned is the updated version, with no errors present in the response.
- **Logic:** This test ensures the core functionality works as intended when proper conditions are met.
- **Importance:** Fundamental for guaranteeing that users can update their articles as expected.

---

### Scenario 2: Unauthenticated User Cannot Update Article

**Details:**
- **Description:** This test examines the behavior when an unauthenticated request is made. It should confirm that the function returns an error with a status of `Unauthenticated`.

**Execution:**
- **Arrange:** 
  - Mock `auth.GetUserID` to return an error indicating authentication failure.
- **Act:** 
  - Call the `UpdateArticle` function with an appropriate request.
- **Assert:** 
  - Verify that the response is `nil` and an `Unauthenticated` error is returned.

**Validation:**
- **Assertion choice:** Check the error type and message for `Unauthenticated`.
- **Logic:** Ensures the system correctly handles unauthenticated attempts.
- **Importance:** Critical for maintaining security by restricting article updates to legitimate users.

---

### Scenario 3: Non-existent User ID Returns NotFound Error

**Details:**
- **Description:** This test checks the function's response when a valid token is provided, but the user does not exist in the database.

**Execution:**
- **Arrange:** 
  - Mock `auth.GetUserID` to return a valid user ID not present in the `UserStore`.
- **Act:** 
  - Invoke `UpdateArticle` with the given context.
- **Assert:** 
  - Validate that a `NotFound` error is returned with an appropriate message.

**Validation:**
- **Assertion choice:** Confirm the `NotFound` status code and message.
- **Logic:** Verifies the application's response to nonexistent user queries.
- **Importance:** Ensures robustness by gracefully handling invalid user scenarios.

---

### Scenario 4: Invalid Slug in Request Returns InvalidArgument Error

**Details:**
- **Description:** Validates how the function deals with an invalid slug value in the request that cannot be converted to an integer.

**Execution:**
- **Arrange:** 
  - Use a slug that cannot be parsed to an integer within the `UpdateArticleRequest`.
- **Act:** 
  - Call `UpdateArticle` with the malformed request.
- **Assert:** 
  - The error should be classified as `InvalidArgument`.

**Validation:**
- **Assertion choice:** Validate against `InvalidArgument` response to malformed slugs.
- **Logic:** Checks input validation before processing business logic.
- **Importance:** Protects the system from incorrect data affecting operations.

---

### Scenario 5: Updating Another User's Article Returns Forbidden Error

**Details:**
- **Description:** Tests the function's behavior when a user attempts to update an article authored by someone else.

**Execution:**
- **Arrange:** 
  - Set a `UserStore` with a user.
  - Configure `ArticleStore` with an article having an author different from the user making the request.
- **Act:** 
  - Call `UpdateArticle` with an authorized but incorrect user.
- **Assert:** 
  - Ensure a `Forbidden` error is returned denoting permissions failure.

**Validation:**
- **Assertion choice:** Check for `Forbidden` error type.
- **Logic:** Validates access controls for article editing.
- **Importance:** Ensures data integrity and respect for user-owned content boundaries.

---

### Scenario 6: Article Validation Fails, Returning InvalidArgument Error

**Details:**
- **Description:** Ensures an error is returned when the updated article does not pass validation checks (e.g., empty fields).

**Execution:**
- **Arrange:** 
  - Mock updated data that fails validation.
- **Act:** 
  - Invoke `UpdateArticle` with invalid details.
- **Assert:** 
  - A `InvalidArgument` error should result from validation failure.

**Validation:**
- **Assertion choice:** Validate against `InvalidArgument` indicating validation issues.
- **Logic:** Confirms that only valid data is allowed to be saved.
- **Importance:** Maintains data integrity by enforcing business rules.

---

### Scenario 7: Database Update Fails Returning InternalError

**Details:**
- **Description:** Observes how the function processes a database failure during the article update. Should return an internal server error.

**Execution:**
- **Arrange:** 
  - Mock `ArticleStore.Update` to simulate a failure (e.g., database connection issue).
- **Act:** 
  - Attempt updating with valid input data.
- **Assert:** 
  - Confirm an `InternalError` status is produced.

**Validation:**
- **Assertion choice:** Check for `InternalError` to correspond with unexpected database conditions.
- **Logic:** Tests the applicationâ€™s resilience to backend failures.
- **Importance:** Critical for signaling issues that need administrative attention without compromising user-facing experience.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"fmt"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestUpdateArticle(t *testing.T) {
	t.Log("Setting up test environment")

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockAuth := NewMockAuthService(ctrl)
	mockUserStore := NewMockUserStore(ctrl)
	mockArticleStore := NewMockArticleStore(ctrl)

	h := &Handler{
		authSvc:    mockAuth,
		us:         mockUserStore,
		as:         mockArticleStore,
	}

	// Test scenarios
	tests := []struct {
		name        string
		setupMocks  func()
		req         *pb.UpdateArticleRequest
		wantResp    *pb.ArticleResponse
		wantErrCode codes.Code
	}{
		{
			name: "Valid User Updates Article Successfully",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil).Times(1)
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil).Times(1)
				mockArticleStore.EXPECT().GetByID(uint(42)).Return(&model.Article{ID: 42, Author: model.User{ID: 1}}, nil).Times(1)
				mockArticleStore.EXPECT().Update(gomock.Any()).Return(nil).Times(1)
				mockUserStore.EXPECT().IsFollowing(gomock.Any(), gomock.Any()).Return(true, nil).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "42", Title: "Updated Title", Description: "New Description", Body: "New Body"},
			},
			wantResp: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:  "42",
					Title: "Updated Title",
					Body:  "New Body",
				},
			},
			wantErrCode: codes.OK,
		},
		{
			name: "Unauthenticated User Cannot Update Article",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(0), errors.New("unauthenticated")).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "42"},
			},
			wantErrCode: codes.Unauthenticated,
		},
		{
			name: "Non-existent User ID Returns NotFound Error",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(100), nil).Times(1)
				mockUserStore.EXPECT().GetByID(gomock.Any()).Return(nil, errors.New("not found")).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "42"},
			},
			wantErrCode: codes.NotFound,
		},
		{
			name: "Invalid Slug in Request Returns InvalidArgument Error",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "non-integer-slug"},
			},
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Updating Another User's Article Returns Forbidden Error",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil).Times(1)
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil).Times(1)
				mockArticleStore.EXPECT().GetByID(uint(42)).Return(&model.Article{ID: 42, Author: model.User{ID: 2}}, nil).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "42"},
			},
			wantErrCode: codes.PermissionDenied,
		},
		{
			name: "Article Validation Fails, Returning InvalidArgument Error",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil).Times(1)
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil).Times(1)
				mockArticleStore.EXPECT().GetByID(uint(42)).Return(&model.Article{ID: 42, Author: model.User{ID: 1}}, nil).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "42", Title: "", Description: "New Description", Body: "New Body"},
			},
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Database Update Fails Returning InternalError",
			setupMocks: func() {
				mockAuth.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil).Times(1)
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil).Times(1)
				mockArticleStore.EXPECT().GetByID(uint(42)).Return(&model.Article{ID: 42, Author: model.User{ID: 1}}, nil).Times(1)
				mockArticleStore.EXPECT().Update(gomock.Any()).Return(errors.New("database error")).Times(1)
			},
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "42", Title: "Updated Title", Description: "New Description", Body: "New Body"},
			},
			wantErrCode: codes.Internal,
		},
	}

	// Run tests
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMocks()

			resp, err := h.UpdateArticle(context.Background(), tt.req)
			if resp != nil {
				assert.Equal(t, tt.wantResp.Article.Title, resp.Article.Title)
				assert.Equal(t, tt.wantResp.Article.Body, resp.Article.Body)
			}
			if err != nil {
				assert.Equal(t, tt.wantErrCode, status.Code(err))
				t.Logf("Expected an error with code: %v, got err: %v", tt.wantErrCode, err)
			} else {
				t.Log("Test passed successfully!")
			}
		})
	}
}
