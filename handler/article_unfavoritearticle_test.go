// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Azure Open AI and AI Model gpt-4o-standard

ROOST_METHOD_HASH=UnfavoriteArticle_47bfda8100
ROOST_METHOD_SIG_HASH=UnfavoriteArticle_9043d547fd

Here are various test scenarios to cover normal operation, edge cases, and error handling for the `UnfavoriteArticle` function:

### Scenario 1: Unauthenticated User Tries to Unfavorite an Article

**Details:**  
- **Description:** Test the case where an unauthenticated user tries to unfavorite an article, expecting an error.
  
- **Execution:**  
  - **Arrange:** Set the context without user authentication details.
  - **Act:** Call `UnfavoriteArticle`.
  - **Assert:** Verify that the error returned is `codes.Unauthenticated`.

- **Validation:**  
  - Explain that authentication checks are crucial for user-based actions such as unfavoriting an article.
  - This test checks that unauthorized access is properly handled by returning an appropriate error.

### Scenario 2: Valid User Unfavorites an Existing Article

**Details:**  
- **Description:** Test a valid case where a user successfully unfavorites an article they had favorited previously.
  
- **Execution:**  
  - **Arrange:** Authenticate the user, mock the article store to return a valid article by ID.
  - **Act:** Invoke `UnfavoriteArticle` with a valid article slug.
  - **Assert:** Check that the article is returned in the response and no error occurs.

- **Validation:**  
  - Verify that the function properly unfavorites the article and updates its state.
  - This is essential for ensuring that users can manage their article preferences correctly.

### Scenario 3: User with Valid Token, but Database User Not Found

**Details:**  
- **Description:** Checks if the system responds correctly if the current user is not found in the database despite a valid token.
  
- **Execution:**  
  - **Arrange:** Mock the user store to simulate no user found with valid user ID.
  - **Act:** Call the function.
  - **Assert:** Expect an error of type `codes.NotFound`.

- **Validation:**  
  - Ensure that user token validation failure results in appropriate error to alert system administrators or users.
  - Critical for maintaining data integrity and security.

### Scenario 4: Article Slug is Not Convertible to an Integer

**Details:**  
- **Description:** Validate behavior when the article slug provided in the request cannot be parsed into an integer.
  
- **Execution:**  
  - **Arrange:** Provide a slug in string format that isn't a number.
  - **Act:** Call `UnfavoriteArticle`.
  - **Assert:** Confirm error is returned as `codes.InvalidArgument` specifying invalid article ID.

- **Validation:**  
  - Check input validation mechanisms that prevent operation on malformed slugs.
  - Supports ensuring data correctness in application operations.

### Scenario 5: Article Not Found with Given ID

**Details:**  
- **Description:** Scenario when the article requested by slug does not exist.
  
- **Execution:**  
  - **Arrange:** Mock the article store to simulate non-existent article ID.
  - **Act:** Trigger `UnfavoriteArticle`.
  - **Assert:** Ensure an error `codes.InvalidArgument` is raised.

- **Validation:**  
  - Ensures that referencing non-existing data is managed gracefully.
  - Important for user experience by providing clear error messages.

### Scenario 6: Failure Removing Article from Favorites

**Details:**  
- **Description:** Test the function's response if removing an article from the user's favorites fails due to internal error.
  
- **Execution:**  
  - **Arrange:** Mock `DeleteFavorite` to return an error.
  - **Act:** Run `UnfavoriteArticle`.
  - **Assert:** Verify if `codes.InvalidArgument` is returned indicating failure to remove the favorite.

- **Validation:**  
  - Verify that function properly reports back-end operation issues.
  - Critical for diagnosing system issues and ensuring reliable error reporting.

### Scenario 7: Failure in Checking Follow Status

**Details:**  
- **Description:** Observe handling when checking if the user follows the article's author fails.
  
- **Execution:**  
  - **Arrange:** Mock `IsFollowing` to return an error.
  - **Act:** Conduct the unfavorite action.
  - **Assert:** Validate an error `codes.NotFound` representing internal error is returned.

- **Validation:**  
  - Ascertain that unexpected states are caught and reported correctly.
  - Reinforces robust error recovery and reporting mechanisms in complex operations.

These scenarios aim to thoroughly evaluate the `UnfavoriteArticle` function's operations under both typical and uncommon circumstances, emphasizing security, functionality, and reliability throughout various situations.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/golang/mock/gomock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestUnfavoriteArticle(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockUserStore := model.NewMockUserStore(ctrl)
	mockArticleStore := model.NewMockArticleStore(ctrl)
	h := NewHandler(mockUserStore, mockArticleStore, nil)

	t.Run("Unauthenticated User Tries to Unfavorite an Article", func(t *testing.T) {
		ctx := context.Background() // No authentication details in context
		req := &pb.UnfavoriteArticleRequest{Slug: "123"}

		// Act
		_, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.Error(t, err)
		require.Equal(t, codes.Unauthenticated, status.Code(err))
		t.Log("Unauthenticated user cannot unfavorite an article as expected.")
	})

	t.Run("Valid User Unfavorites an Existing Article", func(t *testing.T) {
		userID := uint(1)
		ctx := auth.AddUserToContext(context.Background(), userID) // Adding authentication
		req := &pb.UnfavoriteArticleRequest{Slug: "123"}

		mockUser := &model.User{ID: userID}
		mockUserStore.EXPECT().GetByID(userID).Return(mockUser, nil)

		articleID := uint(123)
		mockArticle := &model.Article{ID: articleID, Author: model.User{ID: 2}}
		mockArticleStore.EXPECT().GetByID(articleID).Return(mockArticle, nil)
		mockArticleStore.EXPECT().DeleteFavorite(mockArticle, mockUser).Return(nil)
		mockUserStore.EXPECT().IsFollowing(mockUser, &mockArticle.Author).Return(false, nil)

		// Act
		resp, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.NoError(t, err)
		require.NotNil(t, resp)
		t.Log("User successfully unfavorited an article.")
	})

	t.Run("User with Valid Token, but Database User Not Found", func(t *testing.T) {
		userID := uint(1)
		ctx := auth.AddUserToContext(context.Background(), userID)
		req := &pb.UnfavoriteArticleRequest{Slug: "123"}

		mockUserStore.EXPECT().GetByID(userID).Return(nil, errors.New("user not found"))

		// Act
		_, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.Error(t, err)
		require.Equal(t, codes.NotFound, status.Code(err))
		t.Log("Valid token but no user found in the database.")
	})

	t.Run("Article Slug is Not Convertible to an Integer", func(t *testing.T) {
		userID := uint(1)
		ctx := auth.AddUserToContext(context.Background(), userID)
		req := &pb.UnfavoriteArticleRequest{Slug: "ABC"} // Invalid slug not convertible

		mockUser := &model.User{ID: userID}
		mockUserStore.EXPECT().GetByID(userID).Return(mockUser, nil)

		// Act
		_, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.Error(t, err)
		require.Equal(t, codes.InvalidArgument, status.Code(err))
		t.Log("Slug is not a convertible integer as expected.")
	})

	t.Run("Article Not Found with Given ID", func(t *testing.T) {
		userID := uint(1)
		ctx := auth.AddUserToContext(context.Background(), userID)
		req := &pb.UnfavoriteArticleRequest{Slug: "456"}

		mockUser := &model.User{ID: userID}
		mockUserStore.EXPECT().GetByID(userID).Return(mockUser, nil)
		mockArticleStore.EXPECT().GetByID(uint(456)).Return(nil, errors.New("not found"))

		// Act
		_, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.Error(t, err)
		require.Equal(t, codes.InvalidArgument, status.Code(err))
		t.Log("Slug corresponds to a non-existing article ID.")
	})

	t.Run("Failure Removing Article from Favorites", func(t *testing.T) {
		userID := uint(1)
		ctx := auth.AddUserToContext(context.Background(), userID)
		req := &pb.UnfavoriteArticleRequest{Slug: "123"}

		mockUser := &model.User{ID: userID}
		mockUserStore.EXPECT().GetByID(userID).Return(mockUser, nil)

		articleID := uint(123)
		mockArticle := &model.Article{ID: articleID, Author: model.User{ID: 2}}
		mockArticleStore.EXPECT().GetByID(articleID).Return(mockArticle, nil)
		mockArticleStore.EXPECT().DeleteFavorite(mockArticle, mockUser).Return(errors.New("deletion failed"))

		// Act
		_, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.Error(t, err)
		require.Equal(t, codes.InvalidArgument, status.Code(err))
		t.Log("An error was returned when failing to remove article from favorites.")
	})

	t.Run("Failure in Checking Follow Status", func(t *testing.T) {
		userID := uint(1)
		ctx := auth.AddUserToContext(context.Background(), userID)
		req := &pb.UnfavoriteArticleRequest{Slug: "123"}

		mockUser := &model.User{ID: userID}
		mockUserStore.EXPECT().GetByID(userID).Return(mockUser, nil)

		articleID := uint(123)
		mockArticle := &model.Article{ID: articleID, Author: model.User{ID: 2}}
		mockArticleStore.EXPECT().GetByID(articleID).Return(mockArticle, nil)
		mockArticleStore.EXPECT().DeleteFavorite(mockArticle, mockUser).Return(nil)
		mockUserStore.EXPECT().IsFollowing(mockUser, &mockArticle.Author).Return(false, errors.New("failed to check follow status"))

		// Act
		_, err := h.UnfavoriteArticle(ctx, req)

		// Assert
		require.Error(t, err)
		require.Equal(t, codes.NotFound, status.Code(err))
		t.Log("Error reported when failing to check follow status.")
	})

	// TODO: Add more edge case scenarios as required
}
