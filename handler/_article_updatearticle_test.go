// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UpdateArticle_c5b82e271b
ROOST_METHOD_SIG_HASH=UpdateArticle_f36cc09d87

FUNCTION_DEF=func (h *Handler) UpdateArticle(ctx context.Context, req *pb.UpdateArticleRequest) (*pb.ArticleResponse, error)
Based on the provided function and context, here are several test scenarios for the `UpdateArticle` function:

```
Scenario 1: Successful Article Update

Details:
  Description: Test the successful update of an article by its author with valid input data.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns an existing article owned by the user
    - Prepare a valid UpdateArticleRequest with updated title, description, and body
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a non-nil ArticleResponse and nil error
    - Check that the returned article has the updated fields
    - Ensure the article's author profile is correctly populated
Validation:
  This test ensures the core functionality of updating an article works as expected when all inputs are valid and the user has the necessary permissions. It's crucial for verifying the happy path of the update process.

Scenario 2: Unauthenticated User Attempt

Details:
  Description: Test the function's behavior when an unauthenticated user attempts to update an article.
Execution:
  Arrange:
    - Set up a mock context that fails to provide a valid user ID
  Act:
    - Call UpdateArticle with the prepared context and a valid request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with Unauthenticated code
Validation:
  This test is important for ensuring that the authentication check works correctly, preventing unauthorized access to article updates.

Scenario 3: User Attempting to Update Another User's Article

Details:
  Description: Test the function's response when a user tries to update an article they don't own.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns an existing article owned by a different user
    - Prepare a valid UpdateArticleRequest
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with Unauthenticated code and "forbidden" message
Validation:
  This test ensures that the function correctly enforces ownership rules, preventing users from modifying articles they don't own.

Scenario 4: Invalid Article Slug

Details:
  Description: Test the function's handling of an invalid article slug that can't be converted to an integer.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Prepare an UpdateArticleRequest with an invalid (non-numeric) slug
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with InvalidArgument code
Validation:
  This test checks the function's input validation, ensuring it properly handles and reports invalid article identifiers.

Scenario 5: Article Not Found

Details:
  Description: Test the function's response when the requested article doesn't exist.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock article service that returns an error indicating the article wasn't found
    - Prepare a valid UpdateArticleRequest with a non-existent article ID
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with InvalidArgument code
Validation:
  This test ensures the function correctly handles and reports attempts to update non-existent articles.

Scenario 6: Article Validation Failure

Details:
  Description: Test the function's behavior when the updated article fails validation.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock services that return valid user and article
    - Prepare an UpdateArticleRequest with invalid data (e.g., empty title)
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with InvalidArgument code
Validation:
  This test checks that the function properly validates the updated article data before saving, ensuring data integrity.

Scenario 7: Database Update Failure

Details:
  Description: Test the function's handling of a database error during article update.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock services that return valid user and article
    - Configure the mock article service to return an error on update
    - Prepare a valid UpdateArticleRequest
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with InvalidArgument code and "internal server error" message
Validation:
  This test ensures the function correctly handles and reports database errors, maintaining system reliability.

Scenario 8: Following Status Retrieval Failure

Details:
  Description: Test the function's response when unable to determine the following status between the current user and the article author.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create mock services that return valid user and article
    - Configure the user service to return an error when checking following status
    - Prepare a valid UpdateArticleRequest
  Act:
    - Call UpdateArticle with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a gRPC error with NotFound code and "internal server error" message
Validation:
  This test verifies that the function properly handles errors in retrieving related user data, ensuring robust error handling throughout the update process.
```

These test scenarios cover a wide range of possible situations, including successful operations, various error conditions, and edge cases. They aim to thoroughly test the `UpdateArticle` function's behavior under different circumstances.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
)

// Mock structures
type mockUserStore struct {
	mock.Mock
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) Update(article *model.Article) error {
	args := m.Called(article)
	return args.Error(0)
}

func TestUpdateArticle(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*mockUserStore, *mockArticleStore)
		input          *pb.UpdateArticleRequest
		expectedOutput *pb.ArticleResponse
		expectedError  error
	}{
		{
			name: "Successful Article Update",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(nil)
				us.On("IsFollowing", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(true, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
				},
			},
			expectedOutput: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
					Author:      &pb.Profile{Following: true},
				},
			},
			expectedError: nil,
		},
		{
			name: "Unauthenticated User Attempt",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				// No mocks needed for this scenario
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "1"},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name: "User Attempting to Update Another User's Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "1"},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.Unauthenticated, "forbidden"),
		},
		{
			name: "Invalid Article Slug",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "invalid"},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Article Not Found",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(999)).Return((*model.Article)(nil), errors.New("article not found"))
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{Slug: "999"},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name: "Article Validation Failure",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "", // Empty title should fail validation
				},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "validation error: Title: cannot be blank."),
		},
		{
			name: "Database Update Failure",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(errors.New("database error"))
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "Valid Title",
				},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "internal server error"),
		},
		{
			name: "Following Status Retrieval Failure",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(nil)
				us.On("IsFollowing", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(false, errors.New("database error"))
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "Valid Title",
				},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.NotFound, "internal server error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			mockUS := new(mockUserStore)
			mockAS := new(mockArticleStore)
			tt.setupMocks(mockUS, mockAS)

			// Create handler with mocks
			h := &Handler{
				us: &store.UserStore{Store: mockUS},
				as: &store.ArticleStore{Store: mockAS},
			}

			// Setup context with user ID
			ctx := context.Background()
			ctx = auth.NewContext(ctx, 1)

			// Call the function
			got, err := h.UpdateArticle(ctx, tt.input)

			// Assert results
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedOutput, got)
			}

			// Assert that all expected mock calls were made
			mockUS.AssertExpectations(t)
			mockAS.AssertExpectations(t)
		})
	}
}
