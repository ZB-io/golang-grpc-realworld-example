// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UpdateArticle_c5b82e271b
ROOST_METHOD_SIG_HASH=UpdateArticle_f36cc09d87

FUNCTION_DEF=func (h *Handler) UpdateArticle(ctx context.Context, req *pb.UpdateArticleRequest) (*pb.ArticleResponse, error)
Based on the provided function and context, here are several test scenarios for the `UpdateArticle` function:

```
Scenario 1: Successfully Update an Article

Details:
  Description: This test verifies that an authenticated user can successfully update their own article with valid data.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up a mock UserStore that returns a valid user
    - Set up a mock ArticleStore that returns an existing article owned by the user
    - Create a valid UpdateArticleRequest with updated article data
  Act:
    - Call the UpdateArticle function with the prepared context and request
  Assert:
    - Verify that the function returns a non-nil ArticleResponse
    - Check that the returned article has the updated fields
    - Ensure no error is returned
Validation:
  This test is crucial as it verifies the core functionality of updating an article. It ensures that authenticated users can modify their own articles, which is a fundamental feature of the application.

Scenario 2: Attempt to Update Another User's Article

Details:
  Description: This test checks that a user cannot update an article they don't own.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up a mock UserStore that returns a valid user
    - Set up a mock ArticleStore that returns an existing article owned by a different user
    - Create a valid UpdateArticleRequest
  Act:
    - Call the UpdateArticle function with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that an error with codes.Unauthenticated is returned
    - Ensure the error message contains "forbidden"
Validation:
  This test is important for security, ensuring that users can only modify their own content and not that of others.

Scenario 3: Update Article with Invalid Data

Details:
  Description: This test verifies that the function handles invalid article data correctly.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock stores returning valid user and article data
    - Create an UpdateArticleRequest with invalid article data (e.g., empty title)
  Act:
    - Call the UpdateArticle function with the prepared context and invalid request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that an error with codes.InvalidArgument is returned
    - Ensure the error message contains "validation error"
Validation:
  This test ensures data integrity by verifying that the function properly validates input data before updating an article.

Scenario 4: Update Non-Existent Article

Details:
  Description: This test checks the behavior when trying to update an article that doesn't exist.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up a mock UserStore that returns a valid user
    - Set up a mock ArticleStore that returns an error when GetByID is called
    - Create a valid UpdateArticleRequest with a non-existent article ID
  Act:
    - Call the UpdateArticle function with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that an error with codes.InvalidArgument is returned
    - Ensure the error message contains "invalid article id"
Validation:
  This test is important for error handling, ensuring that the function gracefully handles attempts to update non-existent articles.

Scenario 5: Update Article with Unauthenticated User

Details:
  Description: This test verifies that an unauthenticated user cannot update any article.
Execution:
  Arrange:
    - Create a mock context that fails authentication
    - Create a valid UpdateArticleRequest
  Act:
    - Call the UpdateArticle function with the unauthenticated context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that an error with codes.Unauthenticated is returned
    - Ensure the error message contains "unauthenticated"
Validation:
  This test is crucial for security, ensuring that only authenticated users can perform update operations.

Scenario 6: Handle Database Error During Update

Details:
  Description: This test checks the function's behavior when a database error occurs during the update process.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock stores returning valid user and article data
    - Configure the mock ArticleStore to return an error when Update is called
    - Create a valid UpdateArticleRequest
  Act:
    - Call the UpdateArticle function with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that an error with codes.InvalidArgument is returned
    - Ensure the error message contains "internal server error"
Validation:
  This test ensures that the function handles database errors gracefully, providing appropriate error responses without exposing internal details.

Scenario 7: Update Article with Invalid Slug

Details:
  Description: This test verifies the function's behavior when given an invalid slug that can't be converted to an integer.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock stores returning valid user data
    - Create an UpdateArticleRequest with an invalid slug (e.g., "not-a-number")
  Act:
    - Call the UpdateArticle function with the prepared context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse
    - Check that an error with codes.InvalidArgument is returned
    - Ensure the error message contains "invalid article id"
Validation:
  This test is important for input validation, ensuring that the function properly handles and reports invalid slug formats.
```

These test scenarios cover a range of normal operations, edge cases, and error handling situations for the `UpdateArticle` function. They test authentication, authorization, data validation, error handling, and core functionality, providing comprehensive coverage of the function's behavior.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestHandlerUpdateArticle(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*mockUserStore, *mockArticleStore)
		ctx            context.Context
		req            *pb.UpdateArticleRequest
		expectedResp   *pb.ArticleResponse
		expectedErrMsg string
		expectedCode   codes.Code
	}{
		{
			name: "Successfully Update an Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(nil)
				us.On("IsFollowing", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(false, nil)
			},
			ctx: context.WithValue(context.Background(), "user_id", uint(1)),
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
				},
			},
			expectedResp: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
					Author:      &pb.Profile{},
					Favorited:   true,
				},
			},
			expectedErrMsg: "",
			expectedCode:   codes.OK,
		},
		{
			name: "Attempt to Update Another User's Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
			},
			ctx: context.WithValue(context.Background(), "user_id", uint(1)),
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "1",
				},
			},
			expectedResp:   nil,
			expectedErrMsg: "forbidden",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Update Article with Invalid Data",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
			},
			ctx: context.WithValue(context.Background(), "user_id", uint(1)),
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "", // Invalid empty title
				},
			},
			expectedResp:   nil,
			expectedErrMsg: "validation error",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name: "Update Non-Existent Article",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(999)).Return(nil, errors.New("article not found"))
			},
			ctx: context.WithValue(context.Background(), "user_id", uint(1)),
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "999",
				},
			},
			expectedResp:   nil,
			expectedErrMsg: "invalid article id",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name:       "Update Article with Unauthenticated User",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {},
			ctx:        context.Background(), // No user_id in context
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "1",
				},
			},
			expectedResp:   nil,
			expectedErrMsg: "unauthenticated",
			expectedCode:   codes.Unauthenticated,
		},
		{
			name: "Handle Database Error During Update",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{Author: model.User{}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(errors.New("database error"))
			},
			ctx: context.WithValue(context.Background(), "user_id", uint(1)),
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "Valid Title",
					Body:  "Valid Body",
				},
			},
			expectedResp:   nil,
			expectedErrMsg: "internal server error",
			expectedCode:   codes.InvalidArgument,
		},
		{
			name:       "Update Article with Invalid Slug",
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {},
			ctx:        context.WithValue(context.Background(), "user_id", uint(1)),
			req: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "not-a-number",
				},
			},
			expectedResp:   nil,
			expectedErrMsg: "invalid article id",
			expectedCode:   codes.InvalidArgument,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUS := new(mockUserStore)
			mockAS := new(mockArticleStore)
			tt.setupMocks(mockUS, mockAS)

			h := &Handler{
				us: mockUS,
				as: mockAS,
			}

			resp, err := h.UpdateArticle(tt.ctx, tt.req)

			if tt.expectedErrMsg != "" {
				assert.Error(t, err)
				st, ok := status.FromError(err)
				assert.True(t, ok)
				assert.Equal(t, tt.expectedCode, st.Code())
				assert.Contains(t, st.Message(), tt.expectedErrMsg)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, resp)
				assert.Equal(t, tt.expectedResp.Article.Slug, resp.Article.Slug)
				assert.Equal(t, tt.expectedResp.Article.Title, resp.Article.Title)
				assert.Equal(t, tt.expectedResp.Article.Description, resp.Article.Description)
				assert.Equal(t, tt.expectedResp.Article.Body, resp.Article.Body)
				assert.Equal(t, tt.expectedResp.Article.Favorited, resp.Article.Favorited)
			}

			mockUS.AssertExpectations(t)
			mockAS.AssertExpectations(t)
		})
	}
}

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) Update(article *model.Article) error {
	args := m.Called(article)
	return args.Error(0)
}
