// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=UpdateArticle_c5b82e271b
ROOST_METHOD_SIG_HASH=UpdateArticle_f36cc09d87

FUNCTION_DEF=func (h *Handler) UpdateArticle(ctx context.Context, req *pb.UpdateArticleRequest) (*pb.ArticleResponse, error)
Based on the provided function and context, here are several test scenarios for the `UpdateArticle` function:

```
Scenario 1: Successfully Update an Article

Details:
  Description: This test verifies that an authenticated user can successfully update their own article with valid data.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up a mock UserStore that returns a valid user
    - Set up a mock ArticleStore that returns an article owned by the user
    - Create a valid UpdateArticleRequest with new article data
  Act:
    - Call UpdateArticle with the mock context and request
  Assert:
    - Verify that the function returns a non-nil ArticleResponse and nil error
    - Check that the returned article matches the updated data
    - Ensure the ArticleStore's Update method was called with the correct data
Validation:
  This test is crucial as it verifies the core functionality of updating an article. It ensures that authorized users can modify their own content, which is a fundamental feature of the application.

Scenario 2: Attempt to Update Another User's Article

Details:
  Description: This test checks that a user cannot update an article they don't own.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up a mock UserStore that returns a valid user
    - Set up a mock ArticleStore that returns an article owned by a different user
    - Create a valid UpdateArticleRequest
  Act:
    - Call UpdateArticle with the mock context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a non-nil error
    - Check that the error code is codes.Unauthenticated
    - Ensure the ArticleStore's Update method was not called
Validation:
  This test is important for security, ensuring that users can only modify their own content and not that of others.

Scenario 3: Update Article with Invalid Data

Details:
  Description: This test verifies that the function rejects updates with invalid article data.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock stores returning valid user and article owned by the user
    - Create an UpdateArticleRequest with invalid data (e.g., empty title)
  Act:
    - Call UpdateArticle with the mock context and invalid request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a non-nil error
    - Check that the error code is codes.InvalidArgument
    - Ensure the ArticleStore's Update method was not called
Validation:
  This test ensures data integrity by verifying that the application enforces validation rules on article updates.

Scenario 4: Update Non-existent Article

Details:
  Description: This test checks the behavior when trying to update an article that doesn't exist.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up a mock UserStore that returns a valid user
    - Set up a mock ArticleStore that returns an error when GetByID is called
    - Create a valid UpdateArticleRequest with a non-existent article slug
  Act:
    - Call UpdateArticle with the mock context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a non-nil error
    - Check that the error code is codes.InvalidArgument
Validation:
  This test ensures proper error handling for cases where the requested article doesn't exist in the system.

Scenario 5: Update Article with Unauthenticated User

Details:
  Description: This test verifies that an unauthenticated request is properly rejected.
Execution:
  Arrange:
    - Create a mock context that simulates an unauthenticated request
    - Create a valid UpdateArticleRequest
  Act:
    - Call UpdateArticle with the mock context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a non-nil error
    - Check that the error code is codes.Unauthenticated
    - Ensure no calls were made to UserStore or ArticleStore
Validation:
  This test is crucial for security, ensuring that only authenticated users can perform update operations.

Scenario 6: Handle Database Error During Update

Details:
  Description: This test checks the error handling when a database error occurs during the update process.
Execution:
  Arrange:
    - Create a mock context with a valid user ID
    - Set up mock stores returning valid user and article owned by the user
    - Configure the mock ArticleStore to return an error when Update is called
    - Create a valid UpdateArticleRequest
  Act:
    - Call UpdateArticle with the mock context and request
  Assert:
    - Verify that the function returns a nil ArticleResponse and a non-nil error
    - Check that the error code is codes.InvalidArgument with "internal server error" message
Validation:
  This test ensures proper error handling for database failures, maintaining system integrity and providing appropriate feedback.
```

These scenarios cover various aspects of the `UpdateArticle` function, including successful updates, authorization checks, data validation, error handling for non-existent resources, authentication checks, and database error handling. They aim to ensure the function behaves correctly under different conditions and maintains the integrity and security of the article update process.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *mockUserStore) IsFollowing(follower, followed *model.User) (bool, error) {
	args := m.Called(follower, followed)
	return args.Bool(0), args.Error(1)
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) Update(article *model.Article) error {
	args := m.Called(article)
	return args.Error(0)
}

func TestHandlerUpdateArticle(t *testing.T) {
	tests := []struct {
		name           string
		userID         uint
		setupMocks     func(*mockUserStore, *mockArticleStore)
		input          *pb.UpdateArticleRequest
		expectedOutput *pb.ArticleResponse
		expectedError  error
	}{
		{
			name:   "Successfully Update an Article",
			userID: 1,
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, UserID: 1, Author: model.User{ID: 1}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(nil)
				us.On("IsFollowing", mock.AnythingOfType("*model.User"), mock.AnythingOfType("*model.User")).Return(false, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
				},
			},
			expectedOutput: &pb.ArticleResponse{
				Article: &pb.Article{
					Slug:        "1",
					Title:       "Updated Title",
					Description: "Updated Description",
					Body:        "Updated Body",
					Author:      &pb.Profile{},
					Favorited:   true,
				},
			},
			expectedError: nil,
		},
		{
			name:   "Attempt to Update Another User's Article",
			userID: 1,
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, UserID: 2, Author: model.User{ID: 2}}, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "1",
				},
			},
			expectedOutput: nil,
			expectedError:  status.Errorf(codes.Unauthenticated, "forbidden"),
		},
		{
			name:   "Update Article with Invalid Data",
			userID: 1,
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, UserID: 1, Author: model.User{ID: 1}}, nil)
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "", // Invalid: empty title
				},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "validation error: title cannot be blank"),
		},
		{
			name:   "Update Non-existent Article",
			userID: 1,
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(999)).Return((*model.Article)(nil), errors.New("article not found"))
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "999",
				},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name:   "Update Article with Unauthenticated User",
			userID: 0,
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				// No mocks needed for this scenario
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug: "1",
				},
			},
			expectedOutput: nil,
			expectedError:  status.Errorf(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name:   "Handle Database Error During Update",
			userID: 1,
			setupMocks: func(us *mockUserStore, as *mockArticleStore) {
				us.On("GetByID", uint(1)).Return(&model.User{ID: 1}, nil)
				as.On("GetByID", uint(1)).Return(&model.Article{ID: 1, UserID: 1, Author: model.User{ID: 1}}, nil)
				as.On("Update", mock.AnythingOfType("*model.Article")).Return(errors.New("database error"))
			},
			input: &pb.UpdateArticleRequest{
				Article: &pb.UpdateArticleRequest_Article{
					Slug:  "1",
					Title: "Updated Title",
				},
			},
			expectedOutput: nil,
			expectedError:  status.Error(codes.InvalidArgument, "internal server error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUS := new(mockUserStore)
			mockAS := new(mockArticleStore)
			tt.setupMocks(mockUS, mockAS)

			h := &Handler{
				us: mockUS,
				as: mockAS,
			}

			ctx := context.WithValue(context.Background(), "user_id", tt.userID)
			resp, err := h.UpdateArticle(ctx, tt.input)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedOutput, resp)
			}

			mockUS.AssertExpectations(t)
			mockAS.AssertExpectations(t)
		})
	}
}
