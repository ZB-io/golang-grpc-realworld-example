// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Azure Open AI and AI Model gpt-4o-standard

ROOST_METHOD_HASH=DeleteArticle_0347183038
ROOST_METHOD_SIG_HASH=DeleteArticle_b2585946c3

```
Scenario 1: Successfully Delete an Article

Details:
  Description: This test verifies the behavior when a user successfully deletes an article they own. It ensures that the function completes without errors and returns an empty response.
Execution:
  Arrange: Mock the function to return a valid user ID, a user that matches the article's author, and an article found by its slug.
  Act: Invoke DeleteArticle with a context having a valid user's authentication and a valid slug request.
  Assert: Check that the returned result is an instance of pb.Empty and the error is nil.
Validation:
  Explain the choice of assertion and the logic behind the expected result. Verifying a successful deletion ensures the function behaves correctly under normal circumstances.
  Discuss the importance of the test in relation to the application's behavior or business requirements. The ability to delete articles is critical to managing content, making this test essential for user satisfaction.

Scenario 2: User Not Authenticated

Details:
  Description: This test checks the function's handling of unauthenticated requests, expecting an Unauthenticated error.
Execution:
  Arrange: Simulate a context without authentication information.
  Act: Call DeleteArticle with the unauthenticated context.
  Assert: Confirm that the function returns nil and an error with codes.Unauthenticated.
Validation:
  Explain the choice of assertion and the logic behind the expected result. The test ensures the function properly restricts access when a user lacks authentication, preserving application security.
  Discuss the importance of the test. Authentication checks are vital to prevent unauthorized resource access, upholding trust and compliance.

Scenario 3: Invalid Slug Format

Details:
  Description: This test is for cases where the slug cannot be converted to an integer, resulting in an InvalidArgument error.
Execution:
  Arrange: Provide a valid authentication context, but use a non-integer slug.
  Act: Invoke DeleteArticle with the malformed slug.
  Assert: Verify that the error returned is codes.InvalidArgument.
Validation:
  Explain the choice of assertion and the logic behind the expected result. The function must handle format errors gracefully, warning users without causing crashes.
  Discuss the importance of the test. Accurate error messaging assists users in correcting input errors, resulting in a smoother experience.

Scenario 4: Article Not Found

Details:
  Description: This test examines how the function handles requests for non-existent articles, expecting an InvalidArgument error.
Execution:
  Arrange: Set up mocks to simulate successful authentication, but the article is absent in the database.
  Act: Execute DeleteArticle with a slug corresponding to a non-existent article.
  Assert: Confirm the function returns an error with codes.InvalidArgument.
Validation:
  Explain the choice of assertion and the logic behind the expected result. Expected behavior is detecting and communicating article absence appropriately.
  Discuss the importance of the test. This test ensures users receive meaningful feedback, enhancing UX when dealing with requests for non-existent resources.

Scenario 5: User Attempting to Delete Another User’s Article

Details:
  Description: This test validates that the function prevents users from deleting articles they do not own, resulting in an Unauthenticated error.
Execution:
  Arrange: Create mocks such that users are authenticated but not the author of the specified article.
  Act: Call DeleteArticle with a valid article belonging to another user.
  Assert: Check for an error with codes.Unauthenticated.
Validation:
  Explain the choice of assertion and the logic behind the expected result. Proper ownership checks are crucial for user integrity and data protection.
  Discuss the importance of the test. Preventing unauthorized deletions preserves content control for article owners, a key security aspect.

Scenario 6: Deletion Operation Fails

Details:
  Description: This test reviews function handling of an unexpected deletion failure due to backend issues, anticipating an Unauthenticated error.
Execution:
  Arrange: Mock a situation where the deletion method fails for valid input preparation.
  Act: Invoke DeleteArticle under conditions causing deletion to fail.
  Assert: Determine if the function responds appropriately with an Unauthenticated error.
Validation:
  Explain the choice of assertion and the logic behind the expected result. Proper error handling is critical for reliability, signaling operation status.
  Discuss the importance of the test. Detecting backend issues allows for timely remediation, ensuring service continuity and user trust.
```

*/

// ********RoostGPT********
package handler

import (
	"context"
	"testing"
	"errors"
	"github.com/DATA-DOG/go-sqlmock"
	"github.com/golang/mock/gomock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"github.com/stretchr/testify/assert"
)

// TestDeleteArticle tests the DeleteArticle function
func TestDeleteArticle(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockUserStore := NewMockUserStore(ctrl)
	mockArticleStore := NewMockArticleStore(ctrl)

	handler := &Handler{
		us: mockUserStore,
		as: mockArticleStore,
	}

	// Table-driven tests
	tests := []struct {
		name           string
		ctx            context.Context
		req            *pb.DeleteArticleRequest
		setupMocks     func()
		expectedResult *pb.Empty
		expectedError  codes.Code
	}{
		{
			name: "Successfully Delete an Article",
			ctx:  context.WithValue(context.Background(), auth.UserIDKey, uint(1)),
			req:  &pb.DeleteArticleRequest{Slug: "1"},
			setupMocks: func() {
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				mockArticleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
				mockArticleStore.EXPECT().Delete(&model.Article{ID: 1, Author: model.User{ID: 1}}).Return(nil)
			},
			expectedResult: &pb.Empty{},
			expectedError:  codes.OK,
		},
		{
			name: "User Not Authenticated",
			ctx:  context.Background(),
			req:  &pb.DeleteArticleRequest{Slug: "1"},
			setupMocks: func() {
				// No mock setup required
			},
			expectedResult: nil,
			expectedError:  codes.Unauthenticated,
		},
		{
			name: "Invalid Slug Format",
			ctx:  context.WithValue(context.Background(), auth.UserIDKey, uint(1)),
			req:  &pb.DeleteArticleRequest{Slug: "abc"},
			setupMocks: func() {
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
			},
			expectedResult: nil,
			expectedError:  codes.InvalidArgument,
		},
		{
			name: "Article Not Found",
			ctx:  context.WithValue(context.Background(), auth.UserIDKey, uint(1)),
			req:  &pb.DeleteArticleRequest{Slug: "99"},
			setupMocks: func() {
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				mockArticleStore.EXPECT().GetByID(uint(99)).Return(nil, errors.New("article not found"))
			},
			expectedResult: nil,
			expectedError:  codes.InvalidArgument,
		},
		{
			name: "User Attempting to Delete Another User’s Article",
			ctx:  context.WithValue(context.Background(), auth.UserIDKey, uint(2)),
			req:  &pb.DeleteArticleRequest{Slug: "1"},
			setupMocks: func() {
				mockUserStore.EXPECT().GetByID(uint(2)).Return(&model.User{ID: 2}, nil)
				mockArticleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
			},
			expectedResult: nil,
			expectedError:  codes.Unauthenticated,
		},
		{
			name: "Deletion Operation Fails",
			ctx:  context.WithValue(context.Background(), auth.UserIDKey, uint(1)),
			req:  &pb.DeleteArticleRequest{Slug: "1"},
			setupMocks: func() {
				mockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				mockArticleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
				mockArticleStore.EXPECT().Delete(&model.Article{ID: 1, Author: model.User{ID: 1}}).Return(errors.New("deletion error"))
			},
			expectedResult: nil,
			expectedError:  codes.Unauthenticated,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMocks()
			resp, err := handler.DeleteArticle(tt.ctx, tt.req)

			if tt.expectedError == codes.OK {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedResult, resp)
			} else {
				assert.Error(t, err)
				assert.Nil(t, resp)
				
				st, _ := status.FromError(err)
				assert.Equal(t, tt.expectedError, st.Code())
			}
		})
	}
}
