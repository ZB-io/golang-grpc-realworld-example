// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=DeleteArticle_0347183038
ROOST_METHOD_SIG_HASH=DeleteArticle_b2585946c3

FUNCTION_DEF=func (h *Handler) DeleteArticle(ctx context.Context, req *pb.DeleteArticleRequest) (*pb.Empty, error)
Here are test scenarios for the `DeleteArticle` function:

```
Scenario 1: Successful Article Deletion

Details:
  Description: Test the successful deletion of an article by an authenticated user who owns the article.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid user ID
    - Mock h.us.GetByID to return a valid user
    - Mock h.as.GetByID to return an article owned by the user
    - Mock h.as.Delete to succeed
  Act:
    - Call DeleteArticle with a valid context and DeleteArticleRequest containing a valid slug
  Assert:
    - Expect the function to return an empty pb.Empty{} and nil error
Validation:
  This test ensures that the happy path of article deletion works correctly. It verifies that an authenticated user can delete their own article, which is a core functionality of the application.

Scenario 2: Unauthenticated User Attempt

Details:
  Description: Test the behavior when an unauthenticated user attempts to delete an article.
Execution:
  Arrange:
    - Mock auth.GetUserID to return an error
  Act:
    - Call DeleteArticle with a context that doesn't contain valid authentication and a DeleteArticleRequest
  Assert:
    - Expect the function to return nil and an error with codes.Unauthenticated
Validation:
  This test verifies that the function correctly handles unauthenticated requests, which is crucial for maintaining the security of the application.

Scenario 3: User Not Found

Details:
  Description: Test the scenario where the authenticated user ID doesn't correspond to an existing user.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid user ID
    - Mock h.us.GetByID to return an error (user not found)
  Act:
    - Call DeleteArticle with a valid context and DeleteArticleRequest
  Assert:
    - Expect the function to return nil and an error with codes.NotFound
Validation:
  This test ensures that the function handles the edge case of a valid token but non-existent user, which could occur if a user was deleted but their token hasn't expired.

Scenario 4: Invalid Slug (Non-Integer)

Details:
  Description: Test the function's behavior when given a non-integer slug.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid user ID
    - Mock h.us.GetByID to return a valid user
  Act:
    - Call DeleteArticle with a valid context and DeleteArticleRequest containing a non-integer slug (e.g., "abc")
  Assert:
    - Expect the function to return nil and an error with codes.InvalidArgument
Validation:
  This test verifies that the function properly handles invalid input, specifically a non-integer slug, which is important for input validation and error handling.

Scenario 5: Article Not Found

Details:
  Description: Test the scenario where the provided slug doesn't correspond to an existing article.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid user ID
    - Mock h.us.GetByID to return a valid user
    - Mock h.as.GetByID to return an error (article not found)
  Act:
    - Call DeleteArticle with a valid context and DeleteArticleRequest containing a valid but non-existent article ID
  Assert:
    - Expect the function to return nil and an error with codes.InvalidArgument
Validation:
  This test ensures that the function correctly handles requests for non-existent articles, which is important for proper error reporting and user feedback.

Scenario 6: Unauthorized Deletion Attempt

Details:
  Description: Test the behavior when a user attempts to delete an article they don't own.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid user ID
    - Mock h.us.GetByID to return a valid user
    - Mock h.as.GetByID to return an article owned by a different user
  Act:
    - Call DeleteArticle with a valid context and DeleteArticleRequest for an article not owned by the authenticated user
  Assert:
    - Expect the function to return nil and an error with codes.Unauthenticated
Validation:
  This test verifies that the function enforces ownership rules, preventing users from deleting articles they don't own, which is crucial for maintaining data integrity and user trust.

Scenario 7: Database Error During Deletion

Details:
  Description: Test the function's behavior when a database error occurs during article deletion.
Execution:
  Arrange:
    - Mock auth.GetUserID to return a valid user ID
    - Mock h.us.GetByID to return a valid user
    - Mock h.as.GetByID to return a valid article owned by the user
    - Mock h.as.Delete to return an error
  Act:
    - Call DeleteArticle with a valid context and DeleteArticleRequest
  Assert:
    - Expect the function to return nil and an error with codes.Unauthenticated
Validation:
  This test ensures that the function handles database errors gracefully, which is important for maintaining system stability and providing appropriate feedback in case of infrastructure issues.
```

These test scenarios cover a range of normal operations, edge cases, and error handling situations for the `DeleteArticle` function. They aim to verify the function's behavior under various conditions, ensuring it meets the expected requirements and handles different scenarios appropriately.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// MockStruct is used to group all mocks together
type MockStruct struct {
	MockGetUserID    *auth.MockGetUserIDFunc
	MockUserStore    *store.MockUserStore
	MockArticleStore *store.MockArticleStore
}

func TestHandlerDeleteArticle(t *testing.T) {
	tests := []struct {
		name           string
		setupMocks     func(*MockStruct)
		req            *pb.DeleteArticleRequest
		expectedErr    error
		expectedStatus codes.Code
	}{
		{
			name: "Successful Article Deletion",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				m.MockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				m.MockArticleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
				m.MockArticleStore.EXPECT().Delete(gomock.Any()).Return(nil)
			},
			req:            &pb.DeleteArticleRequest{Slug: "1"},
			expectedErr:    nil,
			expectedStatus: codes.OK,
		},
		{
			name: "Unauthenticated User Attempt",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(0), errors.New("unauthenticated"))
			},
			req:            &pb.DeleteArticleRequest{Slug: "1"},
			expectedErr:    status.Error(codes.Unauthenticated, "unauthenticated"),
			expectedStatus: codes.Unauthenticated,
		},
		{
			name: "User Not Found",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				m.MockUserStore.EXPECT().GetByID(uint(1)).Return(nil, errors.New("user not found"))
			},
			req:            &pb.DeleteArticleRequest{Slug: "1"},
			expectedErr:    status.Error(codes.NotFound, "not user found"),
			expectedStatus: codes.NotFound,
		},
		{
			name: "Invalid Slug (Non-Integer)",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				m.MockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
			},
			req:            &pb.DeleteArticleRequest{Slug: "abc"},
			expectedErr:    status.Error(codes.InvalidArgument, "invalid article id"),
			expectedStatus: codes.InvalidArgument,
		},
		{
			name: "Article Not Found",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				m.MockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				m.MockArticleStore.EXPECT().GetByID(uint(1)).Return(nil, errors.New("article not found"))
			},
			req:            &pb.DeleteArticleRequest{Slug: "1"},
			expectedErr:    status.Error(codes.InvalidArgument, "invalid article id"),
			expectedStatus: codes.InvalidArgument,
		},
		{
			name: "Unauthorized Deletion Attempt",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				m.MockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				m.MockArticleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 2}}, nil)
			},
			req:            &pb.DeleteArticleRequest{Slug: "1"},
			expectedErr:    status.Error(codes.Unauthenticated, "forbidden"),
			expectedStatus: codes.Unauthenticated,
		},
		{
			name: "Database Error During Deletion",
			setupMocks: func(m *MockStruct) {
				m.MockGetUserID.EXPECT().GetUserID(gomock.Any()).Return(uint(1), nil)
				m.MockUserStore.EXPECT().GetByID(uint(1)).Return(&model.User{ID: 1}, nil)
				m.MockArticleStore.EXPECT().GetByID(uint(1)).Return(&model.Article{ID: 1, Author: model.User{ID: 1}}, nil)
				m.MockArticleStore.EXPECT().Delete(gomock.Any()).Return(errors.New("database error"))
			},
			req:            &pb.DeleteArticleRequest{Slug: "1"},
			expectedErr:    status.Error(codes.Unauthenticated, "failed to delete article"),
			expectedStatus: codes.Unauthenticated,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockGetUserID := auth.NewMockGetUserIDFunc(ctrl)
			mockUserStore := store.NewMockUserStore(ctrl)
			mockArticleStore := store.NewMockArticleStore(ctrl)

			h := &Handler{
				logger: zerolog.Nop(),
				us:     mockUserStore,
				as:     mockArticleStore,
			}

			mocks := &MockStruct{
				MockGetUserID:    mockGetUserID,
				MockUserStore:    mockUserStore,
				MockArticleStore: mockArticleStore,
			}

			tt.setupMocks(mocks)

			ctx := context.WithValue(context.Background(), auth.GetUserIDKey, mockGetUserID.GetUserID)

			_, err := h.DeleteArticle(ctx, tt.req)

			if tt.expectedErr != nil {
				if err == nil {
					t.Errorf("expected error, got nil")
				} else {
					statusErr, ok := status.FromError(err)
					if !ok {
						t.Errorf("expected gRPC status error, got %v", err)
					} else if statusErr.Code() != tt.expectedStatus {
						t.Errorf("expected status code %v, got %v", tt.expectedStatus, statusErr.Code())
					}
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
			}
		})
	}
}
