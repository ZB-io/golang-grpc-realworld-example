// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-grpc-realworld-example using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=DeleteComment_452af2f984
ROOST_METHOD_SIG_HASH=DeleteComment_27615e7d69

FUNCTION_DEF=func (h *Handler) DeleteComment(ctx context.Context, req *pb.DeleteCommentRequest) (*pb.Empty, error)
Based on the provided function `DeleteComment`, here are several test scenarios:

```
Scenario 1: Successfully Delete a Comment

Details:
  Description: This test verifies that a comment is successfully deleted when all conditions are met (authenticated user, valid comment ID, comment belongs to the user and article).
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns a valid comment matching the request
    - Prepare a valid DeleteCommentRequest
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a non-nil pb.Empty{} and a nil error
    - Confirm that the article service's DeleteComment method was called with the correct comment
Validation:
  This test ensures the happy path works as expected, which is crucial for the core functionality of comment deletion.

Scenario 2: Unauthenticated User Attempt

Details:
  Description: This test checks that an unauthenticated user cannot delete a comment.
Execution:
  Arrange:
    - Set up a mock context that fails authentication
    - Prepare a valid DeleteCommentRequest
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a nil pb.Empty{} and an error
    - Check that the error status code is codes.Unauthenticated
Validation:
  This test is important to ensure that only authenticated users can delete comments, maintaining security.

Scenario 3: Invalid Comment ID

Details:
  Description: This test verifies that the function handles an invalid comment ID correctly.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Prepare a DeleteCommentRequest with an invalid (non-integer) ID
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a nil pb.Empty{} and an error
    - Check that the error status code is codes.InvalidArgument
Validation:
  This test ensures proper input validation, preventing errors from propagating further into the system.

Scenario 4: Comment Not Found

Details:
  Description: This test checks the behavior when the specified comment does not exist.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that fails to find the comment
    - Prepare a valid DeleteCommentRequest
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a nil pb.Empty{} and an error
    - Check that the error status code is codes.InvalidArgument
Validation:
  This test ensures the function handles non-existent comments gracefully, providing appropriate feedback.

Scenario 5: Comment Not in the Specified Article

Details:
  Description: This test verifies that a comment cannot be deleted if it doesn't belong to the specified article.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns a valid comment
    - Prepare a DeleteCommentRequest with a mismatched article slug
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a nil pb.Empty{} and an error
    - Check that the error status code is codes.InvalidArgument
Validation:
  This test ensures data integrity by preventing deletion of comments from incorrect articles.

Scenario 6: User Attempting to Delete Another User's Comment

Details:
  Description: This test checks that a user cannot delete a comment they don't own.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns a valid comment owned by a different user
    - Prepare a valid DeleteCommentRequest
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a nil pb.Empty{} and an error
    - Check that the error status code is codes.InvalidArgument
Validation:
  This test is crucial for maintaining user permissions and preventing unauthorized deletions.

Scenario 7: Failure in Comment Deletion Process

Details:
  Description: This test verifies the behavior when the actual deletion process fails.
Execution:
  Arrange:
    - Set up a mock context with a valid user ID
    - Create a mock user service that returns a valid user
    - Create a mock article service that returns a valid comment but fails on deletion
    - Prepare a valid DeleteCommentRequest
  Act: Call the DeleteComment function with the prepared context and request
  Assert:
    - Verify that the function returns a nil pb.Empty{} and an error
    - Check that the error status code is codes.InvalidArgument
Validation:
  This test ensures that the function handles internal errors gracefully and provides appropriate feedback.
```

These scenarios cover various aspects of the `DeleteComment` function, including successful execution, authentication, input validation, data integrity, permissions, and error handling. They provide a comprehensive test suite for this function.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"errors"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type mockUserStore struct {
	getByIDFunc func(uint) (*model.User, error)
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	return m.getByIDFunc(id)
}

type mockArticleStore struct {
	getCommentByIDFunc func(uint) (*model.Comment, error)
	deleteCommentFunc  func(*model.Comment) error
}

func (m *mockArticleStore) GetCommentByID(id uint) (*model.Comment, error) {
	return m.getCommentByIDFunc(id)
}

func (m *mockArticleStore) DeleteComment(comment *model.Comment) error {
	return m.deleteCommentFunc(comment)
}

// Mock auth.NewContext function
func mockNewContext(ctx context.Context, userID uint) context.Context {
	return context.WithValue(ctx, auth.UserIDKey, userID)
}

func TestDeleteComment(t *testing.T) {
	tests := []struct {
		name              string
		setupAuth         func(context.Context) context.Context
		setupUserStore    func(*mockUserStore)
		setupArticleStore func(*mockArticleStore)
		req               *pb.DeleteCommentRequest
		wantErr           bool
		wantErrCode       codes.Code
	}{
		{
			name: "Successfully Delete a Comment",
			setupAuth: func(ctx context.Context) context.Context {
				return mockNewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.getByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{}, nil
				}
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.getCommentByIDFunc = func(id uint) (*model.Comment, error) {
					return &model.Comment{UserID: 1, ArticleID: 1}, nil
				}
				as.deleteCommentFunc = func(comment *model.Comment) error {
					return nil
				}
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "1",
			},
			wantErr: false,
		},
		{
			name: "Unauthenticated User Attempt",
			setupAuth: func(ctx context.Context) context.Context {
				return ctx
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "1",
			},
			wantErr:     true,
			wantErrCode: codes.Unauthenticated,
		},
		{
			name: "Invalid Comment ID",
			setupAuth: func(ctx context.Context) context.Context {
				return mockNewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.getByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{}, nil
				}
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "invalid",
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Comment Not Found",
			setupAuth: func(ctx context.Context) context.Context {
				return mockNewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.getByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{}, nil
				}
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.getCommentByIDFunc = func(id uint) (*model.Comment, error) {
					return nil, errors.New("comment not found")
				}
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "1",
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Comment Not in the Specified Article",
			setupAuth: func(ctx context.Context) context.Context {
				return mockNewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.getByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{}, nil
				}
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.getCommentByIDFunc = func(id uint) (*model.Comment, error) {
					return &model.Comment{UserID: 1, ArticleID: 2}, nil
				}
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "1",
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "User Attempting to Delete Another User's Comment",
			setupAuth: func(ctx context.Context) context.Context {
				return mockNewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.getByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{}, nil
				}
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.getCommentByIDFunc = func(id uint) (*model.Comment, error) {
					return &model.Comment{UserID: 2, ArticleID: 1}, nil
				}
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "1",
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Failure in Comment Deletion Process",
			setupAuth: func(ctx context.Context) context.Context {
				return mockNewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.getByIDFunc = func(id uint) (*model.User, error) {
					return &model.User{}, nil
				}
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.getCommentByIDFunc = func(id uint) (*model.Comment, error) {
					return &model.Comment{UserID: 1, ArticleID: 1}, nil
				}
				as.deleteCommentFunc = func(comment *model.Comment) error {
					return errors.New("deletion failed")
				}
			},
			req: &pb.DeleteCommentRequest{
				Slug: "1",
				Id:   "1",
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			if tt.setupAuth != nil {
				ctx = tt.setupAuth(ctx)
			}

			mockUS := &mockUserStore{}
			if tt.setupUserStore != nil {
				tt.setupUserStore(mockUS)
			}

			mockAS := &mockArticleStore{}
			if tt.setupArticleStore != nil {
				tt.setupArticleStore(mockAS)
			}

			h := &Handler{
				logger: zerolog.Nop(),
				us:     mockUS,
				as:     mockAS,
			}

			_, err := h.DeleteComment(ctx, tt.req)

			if (err != nil) != tt.wantErr {
				t.Errorf("DeleteComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr {
				if statusErr, ok := status.FromError(err); ok {
					if statusErr.Code() != tt.wantErrCode {
						t.Errorf("DeleteComment() error code = %v, wantErrCode %v", statusErr.Code(), tt.wantErrCode)
					}
				} else {
					t.Errorf("DeleteComment() error is not a status error")
				}
			}
		})
	}
}
